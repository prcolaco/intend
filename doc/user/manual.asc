.Introduction

This manual describes the Intend C scripting language. It is
meant to give a complete overview of the language. This
includes syntax, semantics, and standard library functions
provided by the language runtime environment.

..What's Intend C?

Intend C is a scripting language. It is closely modelled on
the C programming language, but with some features removed
and added to create a language more suitable to ad-hoc
scripting. The following is a description of the main
differences between Intend C and C.

Intend C does automatic memory management. This means the
programmer does not have to reserve memory for strings
and arrays. Additionally, variables do not have to be
declared before they are used.

Intend C uses dynamic typing. This means variables can be used
to store arbitrary values. A variable that holds an integer
at the beginning of a script may well be used to hold a
string at the end of the same script. The concept extends
to arrays -- arrays can have elements of different types.

Intend C has anonymous functions. Sometimes you may want to
pass a function into another function (functions can accept
other functions as their arguments), and anonymous functions
provide a way of doing so without having to invent a function
name. This is especially useful if you need a particular
function just once and just for passing into another function.

Intend C provides exception support. Exceptions can be used
for handling error situations in a script. They provide
out-of-band error signalling and handling.

Intend C does not allow user-defined datatypes. This is a
restriction common to many scripting languages. It does, however,
have structure classes, which work a lot like classes in
object-oriented programming languages.

Intend C does not provide a way to define constants -- that is,
values set by the programmer that cannot change during
the execution of a script. The rationale is that it is not
strictly necessary to have constants provided by the language.
One can simply use a global variable and write to it only
once at the beginning of a script.

Apart from the functions listed above, Intend C tries to emulate
C as much as possible. The semantics of language construct
are supposed to match C, and the standard library of functions
uses the same names as the C standard library where both
provide the same functionality.

..Why another scripting language

There is no shortage of existing scripting languages, so why
design and write another one? Three reasons, mainly.

The first reason is that many people, especially in the
Unix community, know how to program in C, but having to do
your own memory management all the time is a pain for small
or quick projects. Intend C provides a way to write "almost C"
code without having to think about memory management. Dynamic
typing was added because it is very convenient to have once
you have already abandoned the need to declare variables
before use (which you have to do in C so that the compiler
can set aside memory for variables).

The second reason for writing another language is that most
scripting languages of today are not really lightweight
anymore. Extensive function libraries often mean that a
scripting language interpreter is several megabytes in size.
For fans of more minimalist approaches, several megabytes
ain't it. Intend C's standard library of functions is based on
that of ISO C for the very reason that it is very compact and
does not provide bells and whistles.

The last but not the least important is the need to have a
simple, light-weight, self-contained, possible to sandbox
language that programmers can easily embed in their current
applications to allow scripting capabilities. Intend C has a
shared library that implements the whole language parser and
standard library that weights only nearly 200K. The command
line tool is just a program that is dynamically linked to the
shared library and passes the configurations and files to it.
Besides this, Intend C counts with several modules that add
to the standard library some extra functionality, as regular
expressions, dynamic library loading (by the language), math
functions, system functions, dynamic memory management, list
array management and dictionary management. These modules can
be loaded dynamically within the scripts allowing each script
to use just the functionality it needs. The user can build new
modules on top of a simple interface and extend the library
to his specific needs.

..Target audience

This manual tries to describe the syntax and semantics of the
Intend C language, but it does not go into every detail and
certainly is no guide on how to solve real problems using
Intend C.

It is assumed the reader already knows how to program. Most
of the language constructs of Intend C appear in other
languages, as well, so already knowing a different
programming language helps. Since Intend C is modelled on C,
knowing C helps a lot. For structure classes, which are not
taken from C, knowledge of object-oriented programming
languages such as C++ or Java should help, since structure
classes are basically a low-level version of classes.

..Versioning

This manual describes the Intend C language, library and
modules version 1.0.XX (all releases of 1.0 version).

In the former Arena project both the interpreter, language
and standard library were versioned. Since version 1.0.0
of Intend C (the successor of 0.9.13 version of Arena
project) this has been unified so that only the interpreter
is versioned, although separated change logs are maintained
for both language, library and modules. The last one was
introduced because the library now is modular, having a
standard base library integrated in the interpreter and
several modules implementing many other non central
functionality.

Incompatible changes to the language, library or modules
result in a change of the major version number of the
interpreter, although the retrocompatibility will be a
goal and will be only challenged if the benefits are huge.
Thus, version 1.0.0 of the interpreter will possibly not
run all version 0.9.13 scripts without minor fixes.

Compatible changes to the language, library or modules
result in a change of the minor version number. Thus
such a new version must still be able to run all scripts
written for a version with the same major version number
and a smaller minor version number. This means that 
interpreter version 1.1.0 will still run all version 1.0,
1.0.1, and 1.0.2 scripts.

The last version number changes for each revision of the 
same version, meaning that the only changes made were bug
fixes and improvements in performance and usability of the
interpreter itself. The language, library and modules will
have the same functionality and interface.

..Structure of this manual

The rest of the text is divided into five main chapters.
The first describes the general concepts of Intend C. The
second describes the syntax and intended semantics of the
language. The third describes the standard library of
functions that come with the language. The fourth describes
the modules that are included with Intend C distribution.
The fifth describes the interface with Intend C library,
how to embed Intend C in other programs and how to extend
Intend C by writing new modules.

..License

The license of Intend C project is different for the tools,
the libraries and documentation. The tools like the command
line interpreter tool are licensed under GNU GPL (General
Public License), the libraries like intend library or core
modules are licensed under GNU LGPL (Lesser or Library
General Public License). This manual is licensed under GNU
FDL (Free Documentation License).

You are free to copy, distribute, display, make derivative
works of, and/or make commercial use of this project work,
provided you follow these conditions:

You must keep any copyright notices and license terms
intact. You are free to add your own copyright notices to
parts of a derivative work that you developed yourself,
as long as you are compliant with all the terms of the
applicable GNU licenses.

If you make changes to the semantics of existing parts
of the project, those parts must carry prominent notice
that you changed them. This condition is made because this
project defines the behavior of a programming language,
and changes to the project can easily change the described
behavior. This could lead to the changed work implementing
another, slightly incompatible language.

.General Concepts

Intend C has a command line tool that allows to execute
script from the command line. This command line tool only
parses the command line and configures a new Intend context
passing it configurations grabbed from the command line
options and executes the desired script file.

All the parsing and execution is handled by the Intend C
Dynamic Library. This library is dynamically linked with the
command line tool and has some API that the tool is aware of
to talk with it.

The same is performed by the Intend C modules. They are also
linked from the Intend C Dynamic Library and implement both an
initialization and destroy functions so the Library can ask the
module to register itself and destroy (free) its resources when
not needed anymore.

..Intend C command line tool

The command line tool has the following syntax:

	intend [ options ] script [ script arguments ]

It uses the first non-option argument as the script file to
execute and passes all following command line arguments to the
script.

Option processing can be aborted by using the special option --.
The next command line argument will be taken as the script to
execute even if it matches a regular interpreter option.

...Options

	-h or --help

Display a short option summary.

	-V or --version

Display the version number of the interpreter.

	-c or --check

Perform only syntax checking. The script will be read and parsed
by the interpreter. Syntax errors will be reported, but the
script is not executed on a successful parse.

	-d or --dump

Dump script contents on standard output. The script will be read
an parsed by the interpreter, but not executed. Instead, the
interpreter prints out its internal parse tree of the script,
converted back into Intend C source code. Comments from the
input script may be missing, and some language constructs may be
expanded to a different form.

This option is intended for debugging the interpreter itself, in
the case that it misinterprets a script.

	-s or --safe

Run the script in safe mode. To know more about safe mode please
refer to the next section.

	-p <name> <path> or --path-ro <name> <path>

This option accepts the arguments <name> and <path> and will
define a read-only named <name> sandbox in <path>. To know more
about sandboxes please refer to the next sections.

	-P <name> <path> or --path-rw <name> <path>

This option accepts the arguments <name> and <path> and will
define a read-write named <name> sandbox in <path>. To know more
about sandboxes please refer to the next sections.

	-l <module> or --load-module <module>

This option accepts a <module> name argument and will add that
module to the list of pre-loaded modules. When Intend C
interpreter is initialized, these pre-loaded modules are loaded
and initialized to be used by the running scripts. To know more
about modules please consult the Modules chapter below.

...Diagnostics

If a syntax or runtime error occurs, the exit status of the
interpreter is 1 and a diagnostic message is printed on standard
error.

If no syntax or runtime error occurs, the exit status of the
interpreter is that of the script executed. Note that some
debugging options of the interpreter itself will preclude the
script from running. In that case the exit status is 0.

..Normal vs Safe Mode

In normal mode, the running script gains access to all the
parts of the host system that the user running it can access.
In a linux environment this is usually not a problem, and other
script languages like bash, perl or python also run in this
mode.

But if you need an embeddable language to use in your program,
you will think twice before allowing it to execute scripts
with this kind of access to the user data. These type of
vulnerabilities are often used by viruses to perform actions
over the user data without his awareness.

Intend C Safe mode prevents the running script to perform the
following activities:

- Accessing any file system resources (outside of the defined
sandboxes);

- Loading any module (besides the ones that are pre-loaded);

- Writing to the environment;

- Using any include files (outside of the defined sandboxes).

All modules that interact with these types of resources, when
applicable, will always behave similarly like the standard
library when it comes to safe mode access.

Although, there are modules to which this kind of access limits
would turn them useless. These modules are identified in their
respective section with a note stating that the use of the
module is not recommended under safe mode execution.

..About Sandboxes

The term sandbox well known among the critical systems and
security guys to represent some closed space where a user or
an intruder can play around without doing anything that can
be risky or damaging to the main system.

Sandboxes in Intend C are available to any function from the
standard library or from any module that requires a filename
or a path.

The use of sandboxes has three main advantages:

The first is that it is simpler to write a short path than a
very long one. If you use sandboxes, you can create one named
inc to the path /usr/local/include and use it in your scripts
as follows:

	include "inc:/api.ih";

instead of the complete path like:

	include "/usr/local/include/api.ih";

The second is that the main program that has the Intend C
embedded can create sandboxes to the scripts that it runs so
that the scripts need no change independently of the place that
the main program is installed in.

The third and more important is that the only way to access
the filesystem in safe mode is through the defined sandboxes.
This means that the host of an intend script must allow
read-only or read-write access to some parts of the filesystem,
so the script can access those places and perform file operations.

Also the include files in safe mode need to be accessed through
a sandbox, which should be setup read-only in highly secure
environments.

The running script may test if it is running in safe mode with
a special constant SAFE_MODE. Here is an example:

	if(SAFE_MODE) {
	    print("I am a prisoner in a tight jail!\n");
	} else {
	    print("I am a free guy! I can do whatever I want!!!\n");
	}


..Extending Intend C with Modules

Modules in Intend C are dynamic libraries that add new data,
functions or classes to Intend C interpreter for use by the
running scripts.

To use a module, the user can pass the -l option on the intend
command line, or do it inside the script like in the following
example:

	use console, math;

or by calling the module_load function:

	module_load("console", "math");

or also with exception handling like:

	try {
	    module_load("console", "math");
	} catch (msg) {
	    printf("Error: %s\n", msg);
	    exit(1);
	}

During the execution of a script a certain module not needed
anymore can be unloaded like this:

	// No more mem functions are needed
	try {
	    module_unload("mem");
	} catch (msg) {
	    printf("Error: %s\n", msg);
	    exit(1);
	}

To know which modules are available with Intend C or how to
write your own modules please see the Modules chapter or the
Interface Description chapter below in this manual.

.Language

This section of the manual describes the syntax and semantics
of the Intend C scripting language.

..Basic tokens

When a script is parsed by the Intend C interpreter, it is
first split up into tokens. These tokens are then combined
to form statements and expressions. Since it is important
to know what kind of tokens (for example, variable and
function names) are accepted by the language, the different
token types are described next.

...Comments

Comments can be part of a script. They are ignored by the
interpreter and can be used to annotate the script for
human readers. There are two forms of comments: one-line
comments and multi-line comments.

One-line comments start with the character "#" (hash) or
the characters "//" (double forward slash). They can be
placed anywhere on an input line and cause the rest of
the line to be treated as a comment. The following are
examples of one-line comments:

	# this line is ignored
	a = 5; // everything back here is ignored

Multi-line comments start with the characters "/*" (forward
slash followed by asterisk) and end with the characters
"*/" (asterisk followed by forward slash). Everything between
those two markings is ignored. Multi-line comments can be
nested -- you need a matching number of "/*" and "*/"
sequences to really end a comment. The following is an
example of a multi-line comment:

	/* this is lengthy explanation of what is happening,
	   but you can probably figure that out yourself */

...Keywords

Keyword are words reserved by the language. They are
used to make up statements and expressions. They cannot
be used as names for variables, functions, or classes.
Keywords are case-sensitive: "do" is a language keyword,
"Do" or "DO" are not.

The following is a list of all Intend C keywords:

	array    break    bool     case     catch    class
	continue default  do       else     extends  false
	float    fn       for      forced   if       include
	int      mixed    new      resource return   string
	struct   switch   throw    true     try      use
	void     while    NULL

...Operators

Operators are special symbols reserved by the language.
They are used to combine expressions and generally
represent operations performed on pieces of data. For
example, the + operator denotes mathematical addition.

The following is a list of all Intend C operator symbols:

	::      ==      !=      <=      >=      <
	>       ++      --      &&      ||      **
	+       -       *       /       %       &
	|       ^       <<      >>      !       ~
	=       +=      -=      *=      /=      &=
	|=      ^=      <<=     >>=

...Identifiers

An identifier is a name used for a variable, a function,
or a structure class. It is used in a script to refer to
entities of the language by name. Identifiers are chosen
by the programmer. The language actually puts some
identifiers in place before a script starts (those for
the standard library of functions), but those are not
reserved in the same way that keywords are -- you can
reuse them for your own variables, functions, or
structure classes if you wish.

An identifier starts with an underscore character or
an upper-case or lower-case letter. A letter is one of
the 26 characters in the range A-Z (no umlauts or
accented letters allowed). For the rest of an identifier,
the same characters are allowed, with the addition
of decimal digits. Decimal digits are characters in the
range 0-9.

Keywords cannot be used as identifiers.

The following is a list of example identifiers:

	foo
	x2
	my_funny_name
	__something

...Integer literals

An integer literal is used to represent an integer number
in a script. An integer literal is made up of an optional
prefix and one or more digits. An integer literal with
no prefix is treated as a decimal number. Decimal digits
are characters in the range 0-9. An integer literal with
the prefix "0" (zero) is treated as an octal number. Octal
digits are characters in the range 0-7. An integer literal
with the prefix "0x" (zero x) is treated as a hexadecimal
number. Hexadecimal digits are characters in the ranges
0-9, a-f, and A-F.

The following are examples of integer literals:

	0
	123
	0755
	0xFF
	0xbeef

...Float literals

A float literal is used to represent a floating point number
in a script. A float literal is made up of zero or more
decimal digits, followed by a period, followed by one or
more decimal digits. A decimal digit is a character in the
range 0-9. Optionally, an exponent can be added to the end
of the literal. This is composed of the letter "e" or "E",
followed by either "+" or "-", followed by one or more
decimal digits. If present, the exponent is used as a base
10 exponent and multiplied with the rest of the number. As
an example, "1E-2" is the same as 1 * 10^(-2) which is
0.01.

The following are examples of float literals:

	1.0
	.25
	0.376568E-10
	1E+30

...String literals

A string literal is used to represent a string inside a
script. A string literal is made up of a single or double
quote character, followed by an arbitrary number of
characters, followed by a matching single or double quote.
If the string literal is enclosed in single quotes, it
cannot contain a single quote. The same applies to string
literals in double quotes; they cannot contain double
quotes. Instead, the escaped single or double quotes need
to be used to include these special characters.

To allow the representation of characters that cannot
directly appear inside a script or string, some escape
sequences are permitted. An escape sequence begins with
the character "\" (backslash). The following escape
sequences are defined:

	\\      a literal backslash
	\"      a double quote
	\'      a single quote
	\b      backspace character
	\e      escape character
	\f      form feed character
	\n      newline character
	\r      carriage return character
	\t      tab character
	\ccc    character with octal character code ccc
	\occc   character with octal character code ccc
	\dccc   character with decimal character code ccc
	\xcc    character with hexadecimal char code cc

For character code escapes, less digits than given above can be
used if the character code needed is small enough. Note that if
any character not listed above follows the backslash, the escape
sequence results in that character. For example, the escape
sequence "\q" results in the character "q".

The following are examples of string literals:

	"Hello"
	'Greetings to you!\n'
	"Hi there \"Mr. Mini\","
	'Is this \'safe\' to use?'
	"All your base are belong to us"
	'Embedded \0 zero \0 characters'

...Grouping symbols

Grouping symbols are used to make up larger entities from
statements and expressions or to change the order in which
script code is executed. The following is a list of the
grouping symbols used by the Intend C language:

	(       )       {      }        [       ]
	.       ;       ,

..Runtime type system

Types are used to provide categories for different kinds of
values that a script deals with. Intend C provides eight
datatypes for use by the programmer. No user-defined types are
possible, but a script can use structure classes to provide
a sort of sub-typing for the struct datatype.

Values of some types can be converted into values of other
types by use of a cast expression. More on that later in the
chapter about expressions.

...void

The void type is used in places where no meaningful value
can be returned. The void type has only one value, which can
written "()" (two parenthesis immediately following each other,
pronounced "void" or "null"), or by the keyword "NULL". All
Intend C functions must return a value. If a function does not
have a meaningful result (for example, a function that outputs
a message to the user), it can return a void value instead of
having to invent something else.

...bool

The bool type is used to represent truth values. It has two
values called "false" and "true". It is normally used to
hold the results of boolean computations or for representing
simple on-off switches.

...int

The int type is used to hold signed integer values. The
precision is at least 32 bits. This means an int can generally
hold integer values between -2^31 and 2^31 - 1.

Intend C does not provide unsigned integers. The rationale for
this is that the additional bit of precision that an unsigned
type provides for large positive integer values is not
enough of a benefit to warrant extra complexity for the
implementation.

...float

The float type is used to represent signed floating point
number. The precision of a float is at least that of an IEEE
double precision floating point number.

Intend C does not provide multiple floating point types with
different precisions, like C does. Like the omission of an
unsigned integer type, this was decided to keep implementation
complexity down to a minimum.

...string

The string type is used to represent an arbitrary sequence
of bytes or characters. It is normally used to represent text.
Note that unlike strings (character pointers, really) in C,
an Intend C string can contain bytes with the value 0 (zero).
In C such a byte would be considered the end of the string.

...array

The array type is used to represent a numbered collection
of values. The types of the values stored in an array,
called the elements of the array, are not constrained. This
means each element can have a different type from the other
elements. An array can have other arrays as elements.

Arrays are indexed using integers, starting at 0. This means
the first element of an array has index 0, the second has
index 1, the third has index 2, and so on.

To create an array in Intend C the code is as follows:

	arr = new array("one", "two", "three");

or alternatively:

	arr = mkarray("one", "two", "three");

Then the values can be accessed with:

	print(arr[0]);

In Intend C the arrays can also be indexed with string keys,
allowing them the functionality of hash tables or vectors. This
is done in the same way as with integers:

	arr["1st"] = "one";
	arr["2nd"] = "two";
	arr["3rd"] = "three";

And then access them with:

	print(arr["1st"]);

or with the corresponding numeric index:

	print(arr[0]);

The first key element in the array is also indexed with the
integer 0, and so on.

Key indexed arrays can also be created with:

	arr = mkkeyarray("1st", "one", "2nd", "two", "3rd", "three");

...struct

The struct (short for structure) type is used to represent
a collection of values. Unlike an array, in which the
elements are referenced by integer indices, the elements
of a struct have names. The order of elements in a struct
is not significant, which is another important difference
to the array type. Elements in a structure are called "fields"
or sometimes "methods" (if they are of type fn, see below).

The names of structure elements are identifier tokens, but
there are also library function that use normal string values
as structure element names. In general, you can think of a
struct as being indexed by string values.

To created a struct in Intend C the code is as follows:

	st = new struct(
	    s1 = "one", 
	    s2 = "two",
	    s3 = "three"
	);

or alternatively:

	st = mkstruct("s1", "one", "s2", "two", "s3", "three");

Then the fields can be accessed with:

	print(st.s1);

...fn

The fn type is used to represent functions. This type allows
an Intend C script to use functions like any other value. For
example, functions can be used as arguments to other functions
or can be returned as results from other functions. It is
also possible to create so-called anonymous functions on the
fly, by use of a special expression that results in an fn
value.

...resource

The resource type is used to represent operating system
resources in use by a script. Examples are file handles or
manually allocated memory. The resource type has automatic
management that ensures that operating system resources are
freed when a resource value is no longer accessible by a
running script.

The contents of a resource value are opaque from the
viewpoint of a running Intend C script.

..Scopes and namespaces

A scope is defined as the area where a given portion of
source code appears a script. A namespace defines a
limited area of visibility for variables, functions,
and structure classes. Both concepts are related and
determine what parts of a script can access other parts of
the same script.

...Top-level vs. function-level scope

The scope of a piece code is determined wholly by its
position in the source code. The scope of a given piece
of code cannot and does not change at runtime.

The scope active at the beginning of a script is the
top-level scope. At this scope, arbitrary statements
can be used, including function and structure class
definitions.

When a function definition begins, the source code scope
changes to function-level scope. At this scope, all
statements except other function definitions and structure
class definitions are allowed. This means function
definitions cannot be nested.

When a function definition ends, the statements that
appeared in the function-level scope become the function's
body. The function body is what gets executed when a
function later is called from other code. After leaving
a function definition, the top-level scope is active
again.

When a structure class definition begins, the scope
remains top-level scope, but the following definitions
up to the end of the structure class definition are
considered to be part of it. Structure class
definitions cannot be nested.

...Global vs. local namespace

Namespaces are areas where variables, functions, and
structure classes are stored. All the named entities
of the language that are used in a script are part of a
namespace. A namespace associates identifiers with
the entities they name. Note that there are no
separate namespaces for variables, functions, and
structure classes. A given identifier can only
be used for one kind of entity at a time.

Namespaces can be visible or invisible to the currently
executing code. Code can only see variables, functions,
and structure classes stored in a visible namespace.
Entities stored in an invisible namespace are involatile
until they become visible again.

There is one special namespace called the global
namespace. This namespace is always visible. Variables
and functions provided by the Intend C standard library
are stored in the global namespace. Code running at
top-level scope has access to only one namespace, the
global namespace.

In addition to the global namespace, there are local
namespaces. A local namespace is created whenever
a function is called. The code inside the function
runs within a local namespace of its own. To this code,
both the global namespace and the local namespace of the
function are visible. The local namespace starts out
empty.

The visibility rules inside a local namespace are as
follows: the local namespace has priority. Only if an
identifier is not found in the local namespace, the
global namespace is consulted. When the namespace
is written to, the write always only effects the
local namespace. If a function attempts to change a
variable it has obtained from the global namespace,
a copy of the variable is created in the local
namespace.

When a function calls another function, another
local namespace is created. The previous local
namespace is invisible to the code inside the
called function. Only when the called function exits,
that namespace becomes visible again.

When a function exits, its local namespace is destroyed.
Everything that was stored in the local namespace is
no longer accessible. You can assume memory that was
used by the local namespace is freed at this point.

What the above boils down to is that functions have
their own set of local variables and can manipulate
them without affecting variables outside of the
function itself.

As a side note, the struct type or structure classes,
which define objects of the struct type,work with a
namespace of their own.

Also, the namespace for lambda functions is independant,
so that the lambda functions can be passed as an argument
or placed in struct fields or arrays and be called in other
namespaces without any problem.

..Statements

Statements provide a way to sequence and structure code.
In other words, statements determine what gets executed
and under which conditions.

The following sections include code examples that make
use of expressions, which have not been described up
to now. Expressions will be explained in the next
chapter.

...Basic rules for statements

Statements are executed in order that they appear in the
top-level scope. Individual statements are end with
a ";" (semicolon) character. Expressions can be used
as statements by simply adding a semicolon at the end
of the expression. For example, if "expr" is a valid
expression, then the following is a valid statement:

	expr;

Using an expression as a statement evaluates the
expression. Evaluation of an expression results in a
value in one of the types provided by the language.
When an expression is used as a statement, that value
is discarded.

Statements can be grouped together into one statement
by using curly braces. The whole block of statements
counts as one statement. When the block is executed, the
statements inside it are executed in the order they are
listed. For example:

	{
	  stmt1;
	  stmt2;
	  stmt3;
	}

The above is a block consisting of three statements. Note
that there is no semicolon at the end of the block itself.
Blocks can be nested arbitrarily deep. Blocks are normally
used when you want to supply a list of statements to 
execute in a place where only one statement is allowed by
the language.

A semicolon all by itself also constitutes a valid
statement that does nothing when executed. Blocks are
allowed to be empty. An empty block does nothing when
executed.

...Include statement

The include statement is made up of the keyword "include"
followed by a string in double quotes, followed by a
semicolon as usual for ending a statement. The string
is used as a filename. The contents of the file are
parsed as source code as if it were present after the line
with the include statement on it.

Note that the included code will be parsed at the
current scope. If the current scope is inside a function,
the included code cannot define functions or structure
classes. Normally include statements are only used at
global scope, for including files that contain libraries of
functions or structure class definitions.

Intend C may search for the named include file in several
places of the system running the script. However, it is
only guaranteed that the current working directory will be
searched.

The include files can be placed inside sandboxes, and the
path of that Sandbox will be the place where Intend C will
look for it. In Safe Mode it is the only way to access
include files. Please see bellow the sections describing
Safe Mode and Sandboxes for more details.

Include files can be nested arbitrarily deep. It is the
responsibility of the programmer to prevent loops.

The following is an example of an include statement used
to read in a file called "library.inc":

	include "library.inc";

or using a sandbox named inc:

	include "inc:/library.inc";

...Control flow statements

Control flow statements influence the order in which
statements are executed, or whether they are executed at
all.

....if statement

The if statement is used to execute code based on a
condition. It consists of the keyword "if", followed by
an expression in parenthesis, followed by a statement
or block. The expression is called a guard expression.

When the if statement is executed, the guard expression
is evaluated. If the resulting value is not of type bool,
it is converted to bool (using the same rules as
for cast expressions, see below). If the result is the
bool value "true", the statement part of the if
statement is executed. If the the result of the guard
expression is "false", the statement part is not executed.

The following is an example of an if statement:

	if (x % 2 == 0)
	  print("x is even!");

If you need to execute multiple statements, use a block
statement.

You can also give a statement to be executed when the
guard expression evaluates to "false". This is done
by following the first statement with the keyword "else"
and another statement. An example:

	if (x % 2 == 0)
	  print("x is even!");
	else
	  print("Sorry, x is uneven!");

....while loop statement

The while loop statement can be used to execute another
statement or block multiple times. It consists of the
keyword "while", followed by a guard expression in
parenthesis, followed by a statement known as the loop
body.

When a while loop is executed, the guard expression
is evaluated, following the same rules as given for
the guard expression of an if statement. If the result
is "true", the loop body is executed. Execution of
the while loop then restarts at the beginning. If the
guard expression evaluates to "false", the loop
body is not executed and the while loop is not 
restarted at the beginning.

These rules mean that a while loop only executes as long
as the guard expression evaluates to "true". If the guard
expression evaluates to "false" the first time it is
considered, the loop body is never executed.

The code inside the while loop normally has side effects
that eventually change the result of the guard
expression to "false".

The following is an example of a while loop with a
block statement as its loop body:

	while (x % 2 == 0) {
	  print("x was even");
	  x = rand(0,999);
	}

....do loop statement

The do loop statement is a close cousin of the while loop
statement; only the positions of the guard expression and
loop body are exchanged. A do loop consists of the keyword
"do", followed by a statement as the loop body, followed
by the keyword "while" and a guard expression in
parenthesis.

When a do loop is executed, the loop body gets executed
first. Then the guard expression is evaluated using the
same rules as given for the guard expression of an if
statement. If the result is "true", the do loop is executed
again. If the result is "false", execution continues after
the loop.

The above rules mean that the body of a do loop is always
executed at least once. It is then executed again as long
as the guard expression evaluates to "true".

The following is an example of a do loop:

	do {
	  now = time();
	} while (now - saved < 10);

....for loop statement

The for loop statement offers a more versatile form of
looping compared to the while and do loops detailed
in the previous two sections. A for loop consists of
the keyword "for", followed by three semicolon-separated
expressions in parenthesis, followed by a statement
that serves as the loop body. The first expression
is called an initialiser expression, the second a guard
expression, and the third a loop expression.

When a for loop executes, the initialiser expression
is evaluated. This happens only once, and the result
of the evaluation is discarded. Then the guard expression
is evaluated using the same rules as given for the guard
expression of an if statement. If the result is "true",
the loop body is executed. Following the loop body, the
loop expression is evaluated and its result discarded.
Execution of the for loop then restarts, omitting the
initialiser expression. If the guard expression
evaluates to "false", the loop body and loop expression
are not executed and execution resumes after the for
loop.

The above rules mean that a for loop executes as long
as its guard expressions evaluates to "true". If it
does not evaluate to "true" on the first execution of a
for loop, the loop body is never executed.

Each of the three expressions in a for loop statement
can be left empty. In that case the (empty) expression is
replaced with the literal constant "true". This means
a for loop with all three expressions left off produces
an infinite loop.

For loops are often used to execute a piece of code
a given number of times. For example, the following
loop prints the word "hello" ten times in a row:

	for (i = 0; i < 10; i++) {
	  print("hello");
	}

....continue statement

The continue statement can be used inside of do, while,
and for loops. It consists of the keyword "continue".

When a continue statement is executed inside of a loop
body, the statements following the continue statement
in the loop body are skipped. Processing continues as
normal for the loop statement in question. Normally this
means the loop's guard expression will be evaluated again.

When a continue statement is executed outside of a loop
body, it has the same effect as an empty statement.

The following is a (silly) example of counting the
number of odd integers between 0 and 99. A for loop
is used and the increment of a counter variable is skipped
by use of a continue statement if the number in
question is even.

	odd = 0;
	for (i = 0; i < 100; i++) {
	  if (i % 2 == 0) continue;
	  ++odd;
	}
	print(odd, " odd numbers found");

....break statement

The break statement can be used inside of do, while,
and for loops (for the use of break in a switch
statement, see the next section). It consists of the
keyword "break".

When a break statement is executed inside of a loop
body, the execution of the rest of the loop body
is skipped. Execution then resumes with the next
statement following the loop statement that contains
the break statement. In effect, execution of that
loop is terminated by the break statement.

When a break statement is executed outside of a loop
body (or switch statement, see below), it has the same
effect as an empty statement.

The following is an example use of break which exits
from an infinite for loop as soon as a random number
between 0 and 99 equals zero.

	for (;;) {
	  number = rand(0, 99);
	  print("my number: ", number, "\n");
	  if (number == 0) break;
	}

....switch statement

The switch statement is used to execute one or more
of a number of statement groups depending on the
value of a guard expression. It consists of the
keyword "switch", followed by a guard expression
in parenthesis, followed by statement groups enclosed
in curly braces.

Two different kinds of statement groups are possible.
There can be an arbitrary number of case groups and
one default group. A case group starts with the keyword
"case" followed by an expression, followed by a colon,
followed by an arbitrary number of statements. If the
last statement in the group is a break statement, this
has a special meaning described below. The default group
consists of the keyword "default" followed by a colon,
followed by an arbitrary number of statements. A break
statement at the end of a default group has no special
meaning relevant to the switch statement, but it still
has its normal effect on an enclosing loop statement.

When a switch statement is executed, its guard expression
is evaluated. The resulting value is then used to decide
which case group to execute. Case groups are considered
in the order that they appear in the switch statement.
When a case group is considered, its expression is
evaluated. If the resulting value is equal (in type and
value) to the value of the guard expression, the
statements inside the case group are executed. If the
last statement of the group is a break statement,
execution of the switch ends and the next statement
executed is the one following the switch statement.
If there is no break at the end of the case group, the
statements of the next group are also executed, without
evaluating the expression of that group. This is called
"fall through". This behaviour continues until either a
break statement at the end of a case group is encountered,
a default statement group is executed, or the switch
statement ends.

If a case group is considered and its value does
not match the value of the switch's guard expression,
the statements in the case group are not executed. The
next case group is considered instead and its
expression will be evaluated and checked. A default group,
if present, is not included in the case statements to
consider for execution.

When all case statements have been considered and no
match was found, the behaviour of the switch statement
depends on the presence of a default group. It it is
present, the statements associated with it are executed.
If it is not present, the switch simply executes
nothing. Note that there is no fall through out of a
default group, execution of a switch always ends once
the last statement of the default group has been executed.

The following example counts how many numbers between
0 and 99 are divisible by 3 or 6. It uses a switch that
evaluates the remainder of a division by 6. It employs fall
through since anything divisible by 6 is also divisible by 3.
It uses a default group to count how many numbers were not
divisible by 3 or 6.

	three = six = none = 0;
	for (i = 0; i < 100; i++) {
	  switch (i % 6) {
	    case 0:
	      ++six;
	    case 3:
	      ++three;
	      break;
	    default:
	      ++none;
	  }
	}
	print(three, "numbers were divisible by 3\n");
	print(six, "numbers were divisible by 6\n");
	print(none, "number were not divisible by either\n");

....try statement

The try statement is used to handle exceptions. It
consists of the keyword "try", followed by a statement,
followed by the keyword "catch", followed by an
identifier in parenthesis, followed by another
statement.

When a try statement is executed, the statement
following the keyword "try" is executed. What gets
executed next depends on whether this statement
causes an exception (by use of a throw statement, see
below).

If the enclosed statement does not causevan exception,
the next statement executed is the statement directly
following the try statement; the statement in the catch
part of the try statement is not executed.

If the enclosed statement does throw an exception,
the value thrown is assigned to a variable with the
identifier given in the catch part of the try
statement. The statement given in the catch part is
then executed. Execution then continues behind the
try statement. The variable with the exception value
remains visible to the code following the try
statement. Executing the catch part of a try
statement is often called "handling" the exception.

It is possible for try statements to be nested
arbitrarily deep. An exception is always handled by
the innermost try statement that encloses the code
that caused the exception.

It is common for both statements in a try statement
to actually be block statements.

The following is an example of a try statement used
to encapsulate two function calls which may cause
exceptions. If an exception occurs, its value is
printed.

	try {
	  a = somefunc();
	  b = someotherfunc();
	} catch (e) {
	  print("exception ", e, " occurred\n");
	}

....throw statement

The throw statement is used to cause an exception.
It consists of the keyword "throw" followed by an
expression.

When a throw statement is executed inside of a
try statement (either directly or because it occurs
inside a function called from within a try statement),
the throw expression is evaluated and the resulting
value becomes the exception value. Execution then
continues with the catch part of the innermost
enclosing try statement.

Note that the above means a throw statement executed
inside a loop body breaks out of the loop if the
handling try statement is outside of the loop.

When a throw statement is executed outside of a
try statement, this is considered a fatal error and
execution of the whole Intend C script is terminated
at the point where the exception was thrown.

The following is an example of the use of a throw
statement to throw an exception with the string value
"oops" as the exception value:

	throw "oops";

...User-defined functions

User-defined functions provide a way to structure code
into separate, named entities. Each function accepts
input values, called function arguments, and computes
a value called the return value of the function when
called.

....Function definition

A function definition declares a user-defined function
to the script interpreter. It consists of the function
return type, followed by an identifier naming the
function, followed by a list of argument types and
names in parenthesis, followed by a statement to be
used as the function body. The individual argument types
and names are separated by commas. The list of arguments
can be left empty.

The return type can be given by using one of the keywords
"void", "bool", "int", "float", "string", "array, "struct",
"resource", or "fn". The intent is to specify that the function
returns a value of the given type when it is called. It is a
fatal error if the code of the function body does not return a
value that has the return type. The special keyword "forced"
can be prefixed to the return type. If it is, it is not
an error if the function attempts to return a value not
having the return type -- instead, the language automatically
casts (see cast expressions, below) the return value to the
appropriate type. The special keyword "mixed" can also be
used in place of a real type to indicate that the return
value of the function does not always have one and the same
type.

Function arguments are specified by using the optional
keyword "forced", followed by a type name (same as the return
type detailed above), followed by an identifier. The
identifier is used to name the argument. When a function
is called, the function's arguments are available to the
function body as variables with names as given in the function
definition. The argument type of an argument is checked when
a function is called. If the "forced" keyword was used, the
argument value is automatically cast to the given type. If not,
it is a fatal error to call the function with an argument value
not matching the given argument type.

The type of a function argument can be left out, in
which case the language behaves as if the type "mixed" had
been specified.

The function body can be any statement. Most functions
contain more than one statement, thus most function
bodies will be block statements.

The return type, name, and argument types of a function
are called the prototype of the function.

When a function definition is executed, the new
function's existence is recorded in the current
namespace. Since function definitions can only occur
at top-level scope, this will always be the global
namespace. It is not an error to define a function
with the same name as an existing variable, function,
or structure class. The new function definition will
override any previous meaning of the same name.

The result value, or return value, of a function is
determined by using a return statement, described
below. A function body that does not use a return
statement will automatically be made to return a void
value by the language runtime system.

The following is an example of a function definition
for a function named "sum" that returns an int value
and excepts two int arguments named "x" and "y",
respectively. The example function body returns the
sum of both int values.

	int sum(int x, int y)
	{
	  return x + y;
	}

The function definition above will result in a fatal
error if passed float arguments, for example. To cause
the language to automatically convert both arguments
to int when the function is called, the definition
would have to be changed to:

	int sum(forced int x, forced int y)
	{
	  return x + y;
	}

....return statement

The return statement is used to set the return value
of a function and terminate the execution of a function
body. It consists of the keyword "return" followed
by an optional expression.

When a return statement is executed inside a function
body, the return expression is evaluated and used
as the return value of the function. If no return
expression is present, a void value is substituted
instead. Statements following the return statement
in the function body are not executed. The effect
of the return statement is to always end the execution
of a function body.

The return value is passed back the caller of the
function.

When a return statement is executed outside of a
function body, it behaves like an empty statement and
the return expression is not evaluated.

The following is an example of a return statement
used to return the bool value "true":

	return true;

...Structure classes

A structure class is a blueprint for constructing
values of type struct. Structure classes support
inheritance, meaning one structure class can build
upon another structure class defined earlier.
Structure classes can define fields and methods
that are to be created when a struct value is
constructed from the class.

A structure class consists of the keyword "class",
followed by an identifier to name the class, followed
by field and method definitions enclosed in curly
braces. Optionally, the name of the class can be
followed by the keyword "extends", or simply with the
character ':' like in C++, and an identifier naming
another structure class that this one will be built
upon.

When a structure class is executed, the new class
is stored in the current namespace and is available to
code following the structure class. Since structure
class can only occur at top-level scope, they are
always stored in the global namespace. It is not an
error if the class name is already used by an existing
variable, function, or other class. The new structure
class overrides any previous definition of the same
name.

See the following sections for examples of structure
classes. See the section "Constructor calls" in the
chapter on expressions for information on how to create
struct values from structure classes.

....Defining structure fields

Structure fields in structure classes are used to
define data fields that will appear in struct values
created from the class. The definition of a structure
field gives the identifier of the field. A value for the
field can also be given, but this is optional.

A structure field definition without value consists
of an identifier followed by a semicolon. When a struct
value is constructed from the class, the resulting
value will have an element named by the identifier that
contains a void value.

A structure field definition with value consists of
an identifier, followed by the assignment operator ("="),
followed by an expression, followed by a semicolon. When
a struct value is constructed from the class, the
resulting value will have an element named by the
identifier that contains the result of evaluating
the expression.

The following is an example of a structure class that
defines two structure fields. The first field is named
"i" and not given a value, the second is called "foo"
and given the constant int expression 42 as a value.

	class example
	{
	    i;
	    foo = 42;
	}

When a class extends another class, both may contain
fields of the same name. The values given by the
extending class have precedence. In the following
example, a struct value constructed from class "bar"
will contain a field called "i" with the int value 2.

	class foo
	{
	    i = 1;
	}
	
	class bar extends foo
	{
	    i = 2;
	}

or with C++ like syntax

	class bar : foo
	{
	    i = 2;
	}

....Defining structure methods

A method is a function stored within a structure. This is
basically the same as a struct field with type fn. The
name "method" was chosen because that is how object-oriented
languages name a similar construct.

A structure method definition inside a structure class is
written exactly like a function definition (see above). The
only difference is that the function definition occurs within
the curly braces enclosing the structure class's definition.

When a struct value is constructed from the structure class,
it will contain an element with the function name from the
function definition. The element will contain a value of type
fn that corresponds to the given function prototype and body.

The following is an example of a structure class that defines
a method called "double", which is given as a function that
will double its int argument.

	class foo
	{
	    int double(int x)
	    {
	        return 2 * x;
	    }
	}

For structure classes extending other structure classes,
the same rules as for structure fields apply: when both
classes define a method of the same name, the definition in
the extending class takes precedence. In the following
example, struct values constructed from the "bar" class
will contain a method called "fiddle" that quadruples its
argument, whereas struct value constructed from the "foo"
class will contain a method called "fiddle" that triples
its argument.

	class foo
	{
	    int fiddle(int x)
	    {
	        return 3 * x;
	    }
	}
	
	class bar extends foo
	{
	    int fiddle(int x)
	    {
	        return 4 * x;
	    }
	}

or with C++ like syntax

	class bar : foo
	{
	    int fiddle(int x)
	    {
	        return 4 * x;
	    }
	}

Note that field and method definitions in a structure class
can be intermixed in any order.

....Constructor method

A constructor method is a structure method definition with
a special name. A method is called the constructor method
if its identifier is the same as the identifier of the
structure class definition it is part of.

Constructor methods play a special role when a struct value
is constructed from a class, as described in the section
"Constructor calls" in the chapter on expressions. Apart
from that, a constructor method behaves identically to other
methods defined by a structure class.

The following is an example of a structure class "foo"
that contains a constructor method that will print out a
message whenever it is called.

	class foo
	{
	    void foo()
	    {
	        print("constructor method foo called!\n");
	    }
	}

..Expressions

Expressions are basically descriptions on how to compute a
value. Determining the value of an expression is called
evaluating the expression. The result of evaluating an
expression, called its value, is a value from one of the
eight built-in types of the Intend C scripting language.

...Basic rules for expression nesting

Expression can be made up of other expressions by use
of several operators which are detailed in the sections
below. The exact meaning of compound expressions such
as "2 + 3 * 5" is determined by precedence and
associativity. For example, in the expression "2 + 3 * 5",
the multiplication is performed before the addition. To
override the order in which parts of an expression are
evaluated, it is possible to put parts of an expression
into parenthesis. The sub-expression thus formed must be
a valid expression in itself and its value will be
evaluated before the rest of the original expression.
For example, to compute the addition before the
multiplication in the aforementioned example, the
expression would have to be changed to "(2 + 3) * 5".

The following sections list all possible types of
expressions supported by the Intend C scripting language.
Precedence and associativity of all language operators
are given near the end of the chapter.

...Constant expressions

A constant expression consists of a literal token.
There are literal tokens for the types void, bool, int,
float, and string.

When a literal token expression is evaluated, the
result is a value of the appropriate type. For
example, the literal expression "12" evaluates to the
int value 12.

The following are examples of constant expressions:

	true
	12.0
	"I'm a string"
	NULL
	42

...Reference expressions

A reference expression is used to refer to a variable
or function. It consists of an identifier.

When a reference expression is evaluated, the result is
the value of the named variable in the current
namespace. If the identifier refers to a function, the
result is a value of type fn. If the identifier is
unknown or names a structure class, the result is
a void value.

The following are examples of reference expressions:

	a
	foo
	some_long_identifier

....Static reference expressions

A static reference expression is used to refer to
elements of a structure class. It consists of
an identifier, followed by the operator symbol "::"
(double colon), followed by another identifier.

The first identifier is a structure class name that is
looked for in the current namespace. If it does
not denote an existing structure class, a fatal
error is generated. Otherwise, a separate namespace
is created. The field and method definitions of
the structure class are then executed inside the
new namespace. The second identifier is then used
like a normal reference expression inside the new
namespace. The new namespace is destroyed after
obtaining the value of the static reference, which
is the value of the whole static reference expression.

The following are examples of static references:

	foo::bar
	some_class::some_field

....Indexing of elements

Indexing is used to refer to elements of array and
struct values. Indices can be placed directly
after reference expressions, static reference
expressions, and all kinds of function and method
calls.

An array index consists of one or more expressions,
each enclosed in square brackets. When an array index
is evaluated, the indexed expression and the expression(s)
used as the index are evaluated. If the result value of
the indexed expression is not an array, a void value is
returned. Otherwise, the result of the index expression
is cast to an integer (see below for type casting rules)
and used as an index into the array. If the resulting
integer index is valid for the array in question, the
element stored at that index is the result of the
indexed expression. Otherwise, the result is a void value.

The following is an example expression that assumes
"a" is the name of an array variable and references
the third element of the array:

	a[2]

As a special case, negative indexing is allowed.
A negative index is taken to be an offset from the
end of the array. This way, the index -1 accesses
the last element of an array. -2 accesses the element
immediately preceding the last element, and so on.
If a negative index reaches beyond the beginning of
an array, the result is a void value.

Struct values contain values indexed by identifiers.
A reference to a struct field consists of the operator
symbol "." (period) followed by an identifier.

When a struct index is evaluated, the preceding
expression is evaluated. If the result is not a
struct value, the result is a void value. Otherwise,
the index identifier is used as an element name
for the struct value. If the struct has an element
of that name, the value stored under that name is
the result of the indexing expression. If the struct
value does not have an element with the given name,
a void value is used as the result.

The following is an example of an expression that
uses "a" as the name of a struct variable and
indexes a field "name" off the variables value:

	a.name

Array and struct indices can be freely mixed.
Multiple array and struct indices can follow
each other. Evaluation proceeds from left to
right. The following are examples of expressions
with multiple indices:

	a[2].foo[3][7].value
	str.data[100]
	a[0][1][2]
	foo.bar.foobar
	a[1].bar.foo[2]

The last example above would be evaluated as follows:
first the variable reference "a" would be evaluated.
If the resulting value is an array, the second element
of the array is accessed. If the result is a struct, the
field named "bar" is accessed. If the result is again a
struct, the field named "foo" is accessed. If this results
in an array value, the third element of that array is
accessed and used as the value for the whole expression.
If any value produced along the way does not have the
expected type (array or struct, depending on the kind of
indexing used), the result of the whole expression is a
void value.

...Cast expressions

Cast expressions are used to convert values from one
type to another. A cast expression consists of an
opening parenthesis, followed by a type name, followed
by closing parenthesis, followed by an expression. No
whitespace is allowed between parenthesis and type name.

The result of a cast expression is obtained by first
computing the value of the inner expression and then
converting it to the type named in the cast expression.
If the value produced by the inner expression already
has the right type, it is directly used as the result
of the cast expression. Otherwise, the type conversion
rules given in the following sections are applied.

This is an example of a cast expression casting the
integer constant "1" to float:

	(float) 1

....Conversion to void

Since the void type has only one value, all values of
all other types are converted to that one value.

....Conversion to bool

Converting a void value to bool results in the bool
value "false".

Converting an int value to bool results in the bool
value "false" if the int value is 0 (zero). Otherwise,
the result is the bool value "true".

Converting a float value to bool results in the bool
value "false" if the float value is 0.0 (zero). Otherwise,
the result is the bool value "true".

Converting a string value to bool results in the
bool value "false" if the string is empty (that is,
contains no characters). Otherwise, the result is
the bool value "true".

Converting an array value to bool results in the
bool value "false" if the array is empty (that is,
contains no elements). Otherwise, the result is the
bool value "true".

Converting a struct value to bool results in the
bool value "false" if the struct is empty (that is,
contains no fields or methods). Otherwise, the result
is the bool value "true".

Converting an fn value to bool results in the bool
value "true".

Converting a resource value to bool results in the
bool value "true".

....Conversion to int

Converting a void value to int results in the int value
0 (zero).

Converting a bool value to int results in the int value
0 (zero) if the bool value is "false". If the bool
value is "true", the resulting int value is 1 (one).

Converting a float value to int results in an int value
that corresponds to the integral part of the float
value. If the integral part of the float value cannot
be represented as an int, the resulting value is
undefined.

Converting a string value to int attempts to interpret
the string as an integer literal. Only an initial part
of the string consisting solely of digits is considered
for conversion.

Converting an array value to int results in an int
value that gives the number of elements in the array.

Converting a struct value to int results in an int
value that gives the number of elements in the struct.

Converting an fn value to int results in the int value
1 (one).

Converting a resource value to int results in the int
value 1 (one).

....Conversion to float

Converting a void value to float results in the float value
0.0 (zero).

Converting a bool value to float results in the float value
0.0 (zero) if the bool value is "false". If the bool
value is "true", the resulting float value is 1.0 (one).

Converting an int value to float results in a float
value with the same integral value as the original int
value and no fractional part.

Converting a string value to float attempts to interpret
the string as an float literal. Only an initial part
of the string consisting solely of character that can
occur in a float literal is considered for conversion.

Converting an array value to float results in an float
value that gives the number of elements in the array.

Converting a struct value to float results in an float
value that gives the number of elements in the struct.

Converting an fn value to float results in the float value
1.0 (one).

Converting a resource value to float results in the float
value 1.0 (one).

....Conversion to string

Converting a void value to string results in an empty
string value.

Converting a bool value to string results in an empty
string value if the bool value is "false" or in a string
value containing the single character "1" (digit one) if
the bool value is "true".

Converting an int value to string results in a string
value containing the integer literal for the original
int value.

Converting a float value to string results in a string
value containing the float literal for the original
float value.

Converting an array value to string results in a string
value containing the cast to string of all array elements
with the format "array(elem1,...,elemN)".

Converting a struct value to string results in a string
value containing the the cast to string of all struct
elements with the format
"struct(field1=value1,...,fieldN=valueN)"

Converting an fn value to string results in a string
value containing the word "function".

Converting a resource value to string results in a string
value containing the word "resource".

....Conversion to array

Converting a string to an array result in exploding the
string to an array of one character per element.

Converting other non-array value to an array results in
a one-element array that contains the original value at
index 0 (zero).

....Conversion to struct

Converting a non-struct value to a struct results in
a struct with a single field named "value" that
contains the original value.

....Conversion to fn

Attempting to convert a non-fn value to fn is a fatal
error.

....Conversion to resource

Attempting to convert a non-resource value to resource is
a fatal error.

...Assignment expressions

An assignment expression is used to assign a value
to a variable. It consists of an identifier, followed
by the assignment operator "=" (equals sign),
followed by an expression.

Evaluation of an assignment expression evaluates the
inner expression and stores the result in the current
namespace, in the form of a variable with the name
given by the identifier in the assignment expression.
Any previous meaning of the same identifier is lost.
The assignment expression itself has the same result
value as the inner expression.

The following is an example expression that assigns
the float value "12.5" to a variable named "val":

	val = 12.5

Note that if an exception is thrown while evaluating
the right side of an assignment, the assignment does
not take place and the variable retains its previous
value.

Since an assignment expression has the assigned
value as its own value, and assignment associates to
the right, it is possible to assign a value to
multiple variables with an expression like this:

	a = b = 0

....Indexing in assignments

Array and struct indices can be used in an assignment
expression just like they can be used in combination
with reference expressions. For example, the
following expression will assign the bool value "true"
to the fifth element of an array stored in the variable
"map":

	map[4] = true

There is a difference to using indices in references,
though. The above example will enforce "map" to be
a variable of type array. If it is not an array before
the assignment, an empty array will be created on the
fly, the fifth element be set to "true", and the
resulting array will be assigned to the variable "map".
In the same way, when struct indexing is used on
something that is not a struct, an empty struct value
will be created on the fly and substituted for the
original non-struct value.

If a negative array index is used in an assignment
that does not fall into the bounds of the array, the
effect is to assign to the first element of the array.

Consider the following example:

	a.foo.data[3] = 12

No matter what the value of the variable "a" is before
the assignment, the following will be true after the
assignment expression was evaluated: "a" will be a
struct with at least the field "foo". The field "foo"
will itself be a struct with a least the field "data".
The field "data" will itself contain an array with
at least four elements, the one at index 3 containing the
int value 12. Values that already had the correct
type for the assignment are not disturbed: for example,
if the "data" field above already existed as an array
of ten elements, it would still be an array of ten elements
after the assignment; just the element at index 3 would
have been overwritten with an int value of 12.

If both an index and the outer assignment have side
effects on the same structure or array, the side
effects of the index expression are discarded after the
value of the index has been computed. In the following
example, the value of "s.sp" is not changed after
evaluation of the whole assignment expression:

	s.stack[s.sp++] = 42


....Combining assignments and operators

Instead of the plain assignment operator, the following
operators can also be used:

	+=      -=      *=       /=     &=      |=
	^=      <<=     >>=

These are all composed of a normal operator symbol of the
Intend C language and the assignment operator symbol. The
meaning of a special assignment is best explained by an
example. Consider this expression using a special
assignment operator:

	a += 2

This expression behaves exactly the same as another, longer
expression:

	a = a + 2

In effect, using a special assignment operator is exactly
the same as first referencing the target of the assignment,
combining the result with the operator and inner expression
given, and assigning the result to the target of the
assignment.

...Function calls

Function calls are used to call library functions or
user-defined functions. A function call consists
of an identifier naming the function, followed by
a comma-separated list of expressions (the function
call arguments) in parenthesis. The argument list
is allowed to be empty.

When a function call expression is evaluated, the
existence of the function is checked. If the identifier
name is not found in the current namespace or does not
refer to a function or fn variable, a fatal error is
generated. If the function is found, the number of
argument expressions is checked against the number of
arguments given in the function's prototype. It is a
fatal error to pass less arguments than present in the
prototype. It is allowed to pass more arguments, extra
arguments will be made available to a function's body as
described below.

When it has been determined that a function call is
valid as described above, the argument expressions are
evaluated. Argument expressions are evaluated from left
to right. The types of the resulting values are checked
against the function's prototype, as described in the
section about function definition statements (above, in
the chapter about statements).

If the argument type check succeeds, a new local
namespace is created. The values of the function's
arguments are then added to the new namespace as if
they were local variables assigned inside the
function's body. For example, consider a function
with the following prototype:

	int mult(int x, int y)

When this function is called with the arguments 42 and
12, the local namespace of the function will contain an
int variable named "x" with initial value 42 and another
int variable named "y" with initial value 12.

In addition to the named arguments, the local int
variable "argc" is defined and is assigned the number of
arguments actually passed to the function. The variable
"argv" is also defined and contains an array filled with
copies of all function arguments. The function's body
can use these two variables to gain access to extra
parameters given in a call of the function, beyond those
named in the function's prototype.

When these preparations are complete, the function's
body is executed inside its own local namespace. If the
function body executes a return statement, the value
used in the statement becomes the result of the
function call expression. If the function does not
explicitly return a value, a void value is automatically
generated. The local namespace of the function is then
destroyed, which frees all local variables, including
the values of the function arguments.

The following are examples of function call expressions:

	printf("Hello World!\n");
	array_merge(a, b ,c);
	versions()
	my_func(12, "foo", 42);

The above rules mean that function arguments are passed
to the function as copies. For example, consider the
function call:

	foo(a, b)

When this function call is evaluates, the variables "a" and
"b" are referenced and copies of their current values
are passed to the body of the function "foo". No matter what
the function does with its argument values, the values of
the variables "a" and "b" as stored in the namespace outside
of the function's body are not changed.

....Passing arguments "by reference"

As detailed in the last section, function arguments are
normally passed into function bodies as copies. Even if
the argument expressions are variable reference, a
function body cannot manipulate the variables themselves.

However, there is a special syntax for passing argument
expressions to a function that makes it possible for the
function's body to influence the value of variables that
are used as arguments. It consists of placing an ampersand
before variable reference expressions or indexed variable
reference expressions that are used as function arguments.
This is called passing "by reference", though Intend C does
not exactly use references for this construct (the method
that Intend C uses is called "copy-retract" or "copy-in
copy-out").

When a function call using this syntax is evaluated, the
normal function call semantics as described in the last
section are in effect. However, when the function's body
finishes executing, the language tries to update the
values of all arguments that were passed "by reference".
This is best explained by an example. Consider the following
function body:

	void swap(mixed a, mixed b)
	{
	  c = a;
	  a = b;
	  b = c;
	}

For example, this function might be called like this:

	swap(&x, &y);

During the function call, the values of the variables "x"
and "y" are available inside the function's body as local
variables "a" and "b" (copy-in). When the function's code
has been executed, the language checks whether the local
variable "a" is still defined. If yes, its value is copied
into the variable "x" outside the function. The same
happens for local variable "b" and "y" outside the
function (copy-out). The order given here is for explanatory
purposes. The language takes care that the copy-out actions
happen atomically with regard to each other -- from the
script's point of view, all copy-out actions look as if
they happen at exactly the same time. For example, the
above example function might be called like this:

	swap(&i, &a[i])

In this case, the array index used for the update of the
second variable will always be the same one that was
used for the actual argument value passed into the
function, even if the function changes its first argument.

If the same variable is passed into a function twice or
more using "by reference" passing more than once, the value of
the variable after the function call will assume the latest
value assigned to one of its references.

Note that passing "by reference" only works for arguments
named in the called function's prototype. It does not
work for arguments accessed via the special "argv" array.

...Basic rules for structure classes

Structure classes are used to construct values of the
struct datatype. This process is called creating an
instance of the class. Another use of a class is
to use a static reference, which means accessing
something inside the structure class without actually
creating an instance.

In both cases, the language needs to create concrete
versions of the abstract definitions given in the
class. This happens as follows: a new local namespace
is created. Inside this namespace, the definitions
given in the class are executed. Field definitions
with values are executed like assignment expressions.
Field definitions without values are executed like
assignment expressions that assign a void value. Method
definitions are executed as normal. The result is a
local namespace that contains all fields and methods
from the class with their default values.

If a class extends another class, the process above is
used recursively, depth-first. This means the chain of
classes extending each other is searched until a
class that does not extend another is found. The
definitions from that class are evaluated first,
followed by those in the class that extends the first
one, and so on until the definitions from the class
that started the process are evaluated. This means 
definitions in a class can override all fields and 
methods from another class that it extends.

If the process was used to create a struct value, the
completed local namespace is then used to populate the
new struct value. If the process was used for evaluating
a static reference, the referenced member is copied and
the namespace discarded.

...Constructor calls

Constructor call expressions are used to create struct
values from structure classes. A constructor call
consists of the keyword "new", followed by an identifier
naming a class, followed by a comma-separated list of
argument expressions enclosed in parenthesis. The argument
list is allowed to be empty.

When a constructor call expression is evaluated, the
identifier is used to look for a structure class
definition in the local and global namespace. It is
a fatal error if none is found. If the class is
found, the initial values of a new struct value are
computed as described under "Basic rules", above.

If a constructor method is defined in the class,
it is called using the argument expressions given
as arguments in the constructor call expression. If
the class itself does not define a constructor method
but a class it extends does, the constructor of the
parent class is called instead. Consider this example:

	class foo
	{
	    void foo()
	    {
	        print("this is foo\n");
	    }
	}
	
	class bar : foo
	{
	    i = 12;
	}

or with Java like syntax

	class bar extends foo
	{
	    i = 12;
	}

When a constructor call is evaluated for class "bar",
the constructor method defined in the "foo" class
will be called. Note that it is legal for there to be
no constructor method to call at all.

Normal argument type checks take place for constructor
methods. Using an incorrect number of arguments or
arguments of unsuitable types results in a fatal error.
Values returned from a constructor (by use of a return
statement) are discarded.

During execution of the constructor method, a special
local variable "this" is defined. It contains a copy
of the struct value that is being constructed. It behaves
like a function argument passed "by reference", meaning
the constructor method's body can use it to access and
change elements in the struct value that is the result
of the whole constructor call expression.

Note that the argument expressions given in the constructor
call expression are only evaluated when a constructor
method is actually called. If no constructor method is
defined, the argument expressions are not evaluated.

At the end of the evaluation of a constructor call expression,
an additional element called "__class" is added to the
new struct value. It contains a string value with the name
of the class used to create the struct value.

An example. The following structure class contains
a constructor method that will set an field called "i"
to the value of the first argument used in the
constructor call expression:

	class foo
	{
	    void foo(int x)
	    {
	        this.i = x;
	    }
	}

The above example can be used in a constructor call
expression like this:

	new foo(12)

The result is a value of type struct. This value will have
three elements: a field called "i" with the int value 12,
a method called "foo", and a field called "__class" that
contains the string value "foo".

...Method calls

A method call works like a normal function call, but
refers to a function defined by a structure class or
contained in a struct value.

The conventions for argument evaluation, type checks
and namespaces are the same as for function calls,
described above.

....Static method calls

A static method calls is used to call a function
defined in a structure class. It consists of an
identifier naming a class, followed by the characters
"::" (double colon), followed by another identifier
naming the method, followed by an argument list of
expressions in parenthesis.

It is a fatal error if the class named by the
first identifier is not defined in the current
namespace. It is also a fatal error if the named
class does not contain, either directly or via
inheritance from an extended class, a method
with the name given by the second identifier.

The following are examples of static method calls:

	foo::bar(1, 2, 3)
	input::check("foo", false)
	login::logout()

....Dynamic method calls

A dynamic method call is used to call a method contained
in a struct value. It consists of appending a single
period, followed by an identifier and an argument list
of expressions in parenthesis, to some other expression
that results in a struct value.

If a method call is appended to a non-struct value or the
named method does not exist in the struct value, a fatal
error is generated.

If the method exists and the arguments are compatible with
its prototype, the method's body is called as described
for normal functions. A special local variable called "this"
is also defined and contains a copy of the struct that
contains the called method. This variable can be used to
access fields and methods stored in the same struct value.
Changes to the variable "this" will be copied into the
real struct variable (if any) when the method body is
finished executing.

The following are examples of dynamic method calls (the
last is a method call applied to the result of a
previous constructor call):

	foo.bar()
	registry[512].files.destroy(2)
	new foo().something("foo", 42)

...Operators

Operators work a lot like functions, but instead of
names and argument lists they consist of an operator
symbol applied to one or more other expressions. Which
other expressions are combined by the operator
depends on the kind of operator, as described next.

A prefix operator expression affects a single inner
expression and consists of the operator symbol prefixed
to another expression.

An infix operator expression affects two inner
expressions and consists of the operator symbol
written between the two other expressions.

A postfix operator expression affects a single inner
expression and consists of the operator symbol suffixed
to another expression.

Operators work on different types of expressions. All
operators automatically cast the values of their
argument expression to a type appropriate to the
operator, as described below for different kinds of
operators.

Not all operators evaluate all of their argument
expressions. The rules for evaluation are also described
below.

....Math operators

Math operators are used to represent arithmetic
operations. They work with values of types int and
float. 

A math operator always evaluates all its argument
expressions. If at least one of the argument
expressions results in a float value, both values are
cast to float before use. Otherwise both values are
cast to int.

There is only a single math prefix operator. It uses
the operator symbol "-" (minus sign) and denotes
negation of the value of the argument expression.

The following table lists the infix math operators and
their respective meanings.

	+     addition
	-     subtraction
	*     multiplication
	/     division
	%     remainder
	**    exponentiation

If the result of a math operator expression falls
outside of the domain of the type of its arguments
(after casting), the result is an undefined value
of the same type as the argument values.

The following are examples of math operator expressions:

	-12
	1 + 2
	1.2 * 5
	2 ** 10

....Boolean operators

Boolean operators are used to represent logic
computations on truth values. When a boolean operator
computes the value of one of its argument expressions,
the result is always cast to bool.

The prefix operator "!" (exclamation mark) denotes
logical negation. It always computes the value of its
argument expression.

The infix operator "||" (double vertical bar) denotes
logical disjunction ("or"). It always evaluates its
first, left argument expression. If the result is the
value "true", the result of the whole expression is also
"true" and the second argument expression is not
evaluated. Otherwise, the second argument expression is
evaluated and its bool value is the result of the whole
expression.

The infix operator "&&" (double ampersand) denotes
logical conjunction ("and"). It always evaluates its
first, left argument expression. If the result is the
value "false", the result of the whole expression is also
"false" and the second argument expression is not
evaluated. Otherwise, the second argument expression is
evaluated and its bool value is the result of the whole
expression.

The following are examples of boolean operator expressions:

	!failed
	x && y
	(x || y) && !z

....Equality operators

Equality operators are used to compare values for
equality. The two equality operators always evaluate
both their argument values. No casting of the resulting
values takes place.

If both arguments to an equality operator are of type
array, struct, or resource, the result of the equality
operator expression will not be granted to have the
expected value.

The operator "==" (double equals sign) denotes an
equality test. The value of the whole expression is "true"
if both argument values are of the same type and
represent the same value of that type. Otherwise the
value of the whole expression is "false".

For values of type fn, two values are considered equal
if and only if they refer to the same function body.

The operator "!=" (exclamation mark followed by equals
sign) denotes an inequality test. The value of the
whole expression is "true" if the argument values are
of different types or do not represent the same value
if they are of the same type. Otherwise the value of
the whole expression is "false".

The following are examples of equality operator
expressions:

	1 != 2
	x == "foo"
	divisor != 0.0

....Order operators

Order operators are used to compare the ordering of
two values with respect to each other. An order
operator always evaluates both of its argument
expressions. If only one of the values is a literal
constant, the other value is cast to the same type.
Otherwise, the second value is cast to the type of
the first value (the first value is the one produced
by the argument expression on the left of the operator
symbol).

Possible result values of an order operator expression
are "true" and "false", depending on whether the
ordering the expression checks for is present for the
argument values.

Ordering of void values is always "false" by convention
since there is only one value in the datatype.

Ordering of bool values is such that the value "false"
is smaller than "true", but not equal.

Ordering of int values is the same as for whole numbers
in mathematics.

Ordering of float values is the same as for rational
numbers in mathematics.

Ordering of string values is such that the bytes
forming the string are compared from left to right,
interpreting them as numbers in the range 0-255. The
comparison stops as soon as one of the bytes is
smaller or larger than the other one. The string with
larger byte is considered to be larger than the other.
If both bytes are the same, the comparison moves on to
the next byte in both strings. If this process reaches
the end of exactly one of the strings, that string is
considered to be the smaller of the two. If the process
reaches the end of both strings at the same time, the
strings are considered equal.

Ordering of array, struct, fn, and resource values is
uncertain.

The following table lists all order operators and
the condition that they check for.

	<    left value smaller than right value
	>    left value larger than right value
	<=   left value smaller or equal to right value
	>=   left value larger or equal to right value

The following are examples of order operator
expressions:

	a < b
	x >= 10
	epsilon < 0.01

....Bitwise operators

Bitwise operators are used to manipulate bits in int
values. A bitwise operator always evaluates all of
its argument expressions and casts their values to int.

The prefix operator "~" (tilde) denotes bitwise
negation of its argument value.

The prefix operator "++" (double plus sign) returns
the value of its argument expression increased by one.
If the argument is a reference expression or indexed
reference expression, the increased value is also
stored in the namespace in the same place that the
original value was obtained from.

The prefix operator "--" (double minus sign) returns
the value of its argument expression decreased by one.
If the argument is a reference expression or indexed
reference expression, the decreased value is also
stored in the namespace in the same place that the
original value was obtained from.

The infix operator "|" (vertical bar) computes the
bitwise "or" of its argument values. This means bits
set in either of the argument values will be set in the
result value.

The infix operator "&" (ampersand) computes the bitwise
"and" of its argument values. This means only bits set
in both the argument values will be set in the result
value.

The infix operator "^" (caret) computes the bitwise
"exclusive or" of its argument values. This means only
bits set in exactly one of the argument values will be
set in the result value.

The postfix operator "++" (double plus sign) returns
the value of its argument expression. In addition, if
the argument expression is a reference or indexed
reference expression, the value stored in the namespace
is increased by one. The previous value is returned
as result of the whole expression.

The postfix operator "--" (double minus sign) returns
the value of its argument expression. In addition, if
the argument expression is a reference or indexed
reference expression, the value stored in the namespace
is decreased by one. The previous value is returned
as result of the whole expression.

The following are examples of bitwise operator
expressions:

	i++
	flags & 0x40
	x ^ y
	--refcount

....Operator precedence

If multiple operators occur in one expression, the order
in which they are evaluated depends on the relative
precedence of the two operators. Operators with higher
precedence are evaluated first.

If the same operator occurs multiple times in an
expression, the order of evaluation depends on the
associativity of the operator. If the operator is
left-associative, it is evaluated so that applications
proceed from left to right. For a right-associative
operator, applications proceed from right to left.

To change the order of evaluation or to use
more than one instance of a non-associative operator
in a single expression, the programmer can enclose
subexpressions in parenthesis. Expressions inside
parenthesis are evaluated first, independent of
any operators outside the parenthesis.

The following table lists all operator symbols. Operators
listed at the top have lower precedence than those listed
below them. Operators listed on the same line have the
same precedence. Associativity is given on the same line
as the operator symbols it applies to.

	Associativity   Operators
	right           = += -= *= /= |= &= ^= <<= >>=
	none            ?
	right           ||
	right           &&
	right           !
	none            == != < <= > >=
	left            & | ^
	left            + - (infix)
	left            * / %
	right           **
	left            << >>
	left            ~ - (postfix)
	left            ++ --

Casts have higher precedence than any operator and
associate to the right.

...Conditional expression

A conditional expression is the expression equivalent
to an if-else statement. It consists of an expression,
followed by a "?" (question mark) character, followed
by another expression, followed by a ":" (colon)
character, followed by a third expression.

When a conditional expression is evaluated, the value
of the first argument expression is evaluated and its
result value is cast to bool. If the result is "true",
the value of the second expression is evaluated and
used as the value of the whole expression. The third
expression is not evaluated. If the value of the first
expression is "false", the third expression is evaluated
and its value used as the value of the whole expression.
The second expression is not evaluated in that case.

The following are examples of conditional expressions:

	x % 2 == 0 ? "even" : "odd"
	x ? false : true

...Source file and line expressions

Source file and line expressions are used to refer to
the script they appear in. They are mostly useful for
printing error messages annotated with script source
code locations.

The expression "__FILE__" is evaluated to a string
value that contains the name of the script file that
the expression appears in.

The expression "__LINE__" is evaluated to an int value
that gives the line number that the expressions appears
on, relative to the script file that it appears in.

...Anonymous functions

An anonymous function is a function that does not have
a name. Such a function cannot be defined by use of a
function definition statement since that mandates an
identifier to be used as the function's name. Instead,
an anonymous function can be constructed by an expression
that evaluates to an fn value.

Anonymous functions are useful as arguments to library
functions that expect another function as one of their
arguments. If the argument function is needed only once,
an anonymous function saves the programmer from having
to invent a name for the function.

An anonymous function expression consists of a backslash
character, followed by an argument list definition in
parenthesis, followed by a function body in curly
braces. The argument list definition and function body
have the same syntax as those found in regular function
definitions (see above in the section about statements),
minus the return type definition.

When an anonymous function expression is evaluated,
the result is an fn value which contains a function with
the prototype and function body given in the anonymous
function expression. Note that the return type is not
given in the expression; it is assumed to be "mixed".

The following are examples of anonymous function
expressions:

	\ (x) { return 2 * x; }
	\ (float x) { return sin(x) + 1.0; }
	\ (forced int x, forced int y) { return x + y; }

Anonymous functions are sometimes called "lambda functions".
The choice of the backslash character for leading an
anonymous function expression is influenced by this (since
it is the ASCII character most similar to a Greek lambda) and
was in fact stolen from the functional programming language
Haskell.

The namespace for lambda functions is independant from the
current one, so that the lambda functions can be passed as an
argument or placed in struct fields or arrays and be called
in other namespaces without any problem.

.Standard library

The following sections describe the functions provided by
the Intend C standard library. Functions are grouped into
sections of functions which work alike or on the same
datatypes.

Most of the library was inspired by the ANSI C standard
library, with some influences from Haskell and PHP.

Each function is prefixed by its prototype, which is
followed by a short explanation of what the function
does and what its return values are. Note that no standard
library function modifies any of its arguments, so it
makes no difference whether arguments are passed "by
reference" or normally.

..Pre-defined variables

This part of the library also contains pre-defined variables
that contain information about the precision and possible
values of the float and int types.

...argc

	argc

The int variable argc is defined by the library to contain the
number of command line arguments passed to the script. The
name of the script itself counts as an argument, so this value
is always at least 1 (one).

...argv

	argv

The array variable argv is defined by the library to be an
array of strings containing all the command line arguments of
the script. The first element contains the script name.

...stdin

	stdin

The variable stdin is defined by the library to be the
resource for the standard input stream of the script.
Usually this means the user's keyboard, but many operating
systems allow input redirection from files.

What kind of buffering is performed on stdin is operating
system dependent. Under Unix systems, stdin is normally
line-buffered at the terminal driver level, so that it is
only possible to read from stdin if the user has already
pressed the return key.

...stdout

	stdout

The variable stdout is defined by the library to be the
resource for the standard output stream of the script.
Usually this means writing to stdout will cause output
to appear on the user's screen. However, most operating
systems allow users to redirect stdout to a file.

What kind of buffering is performed on stdout is operating
system dependent.

...stderr

	stderr

The variable stderr is defined by the library to be the
resource for the standard error stream of the script.
Usually this will be the same stream as stdout, but
operating systems often allow the user to redirect this
to a file, independent of stdout.

What kind of buffering is performed on stderr is operating
system dependent.

...FLT_RADIX

	FLT_RADIX

The int variable FLT_RADIX is automatically set by the library
to contain the radix used for the representation of float
values. This is normally 2, meaning binary representation.

...FLT_DIG

	FLT_DIG

The int variable FLT_DIG is automatically set by the library
to contain the precision of float values, measured in decimal
digits.

...FLT_MANT_DIG

	FLT_MANT_DIG

The int variable FLT_MANT_DIG is automatically set by the
library to contain the number of digits, base FLT_RADIX, that
form the mantissa of a float value.

...FLT_MAX_EXP

	FLT_MAX_EXP

The int variable FLT_MAX_EXP is automatically set by the
library to contain the largest positive integer exponent to
which FLT_RADIX can be raised and remain representable as a
float value.

...FLT_MIN_EXP

	FLT_MIN_EXP

The int variable FLT_MIN_EXP is automatically set by the
library to contain the smallest negative integer exponent to
which FLT_RADIX can be raised and remain representable as a
float value.

...FLT_EPSILON

	FLT_EPSILON

The float variable FLT_EPSILON is automatically set by the
library to contain the smallest float value that can be
added to 1.0 so that the result is a float value different
from 1.0.

...FLT_MAX

	FLT_MAX

The float variable FLT_MAX is automatically set by the library
to contain the largest number that can be represented by a
float value.

...FLT_MIN

	FLT_MIN

The float variable FLT_MIN is automatically set by the library
to contain the smallest number that can be represented by a
float value.

...INT_MAX

	INT_MAX

The int variable INT_MAX is automatically set by the library
to contain the maximum value that an int variable can hold.

...INT_MIN

	INT_MIN

The int variable INT_MIN is automatically set by the library
to contain the minimum value that an int variable can hold.

..Runtime system

The runtime system library functions provide ways to deal
with aspects of the runtime system of the language. For
example, since the types of variables are dynamic, there are
functions for checking the type of values.

...sizeof

	int sizeof(mixed x)

The sizeof functions return an integer value of the size of
the variable passed as argument. If the variable is an array,
the result will be the number of elements the array holds. If
the variable is a string, the result will be the size of the
string buffer (not necessarily the same as strlen, because of
the possibility of having '\0' caracters in the middle of the
string buffer. In the case of other types, the returned value
represents the number of bytes of the variable is holding.
The information may not represent the actual allocated memory
of resources or structs, because the size will be always based
on the number of bytes a pointer holds.

...typeof

	string typeof(mixed x)

The typeof function returns a string containing the type of
the argument value "x". It can return "void", "bool", "int",
"float", "string", "array", "struct", "fn", or "resource".

...classof

	mixed classof(mixed x)

The classof function returns the name of the class that
the value "x" was created from, if "x" is a struct and has
been constructed from a structure class. If not, the
classof function returns void.

...is_void

	bool is_void(mixed x, ...)

The is_void function returns true if all of its arguments
are values of type void. It returns false otherwise.

...is_bool

	bool is_bool(mixed x, ...)

The is_bool function returns true if all of its arguments
are values of type bool. It returns false otherwise.

...is_int

	bool is_int(mixed x, ...)

The is_int function returns true if all of its arguments
are values of type int. It returns false otherwise.

...is_float

	bool is_float(mixed x, ...)

The is_float function returns true if all of its arguments
are values of type float. It returns false otherwise.

...is_string

	bool is_string(mixed x, ...)

The is_string function returns true if all of its arguments
are values of type string. It returns false otherwise.

...is_array

	bool is_array(mixed x, ...)

The is_array function returns true if all of its arguments
are values of type array. It returns false otherwise.

...is_struct

	bool is_struct(mixed x, ...)

The is_struct function returns true if all of its arguments
are values of type struct. It returns false otherwise.

...is_fn

	bool is_fn(mixed x, ...)

The is_fn function returns true if all of its arguments
are values of type fn. It returns false otherwise.

...is_resource

	bool is_resource(mixed x, ...)

The is_resource function returns true if all of its arguments
are values of type resource. It returns false otherwise.

...is_a

	bool is_a(mixed x, string type)

The is_a function returns true if the argument "x" has type
"type", using the same type names as given for the typeof
function. Additionally, the "type" argument can also be the
name of a structure class. In this case the is_a function
checks whether "x", which must be struct value, was
constructed from the named class or a class directly
or indirectly extending the named class. The is_a
function returns false if the value "x" does not have the
indicated type.

Note that the meaning of is_a for structure class
is only guaranteed to work reliably as long as all
needed classes are still visible and have not been
overwritten since the struct value in question had been
constructed.

...is_function

	bool is_function(string name)

The is_function function returns true if the argument "name"
refers to a function defined in the local or global
namespace. It returns false otherwise.

...is_var

	bool is_var(string name)

The is_var function returns true if the argument "name"
refers to a variable defined in the local or global
namespace. It returns false otherwise.

...is_class

	bool is_class(string name)

The is_class function returns true if the argument "name"
refers to a structure class defined in the local or
global namespace. It returns false otherwise.

...is_local

	bool is_local(string name)

The is_local function returns true if the argument "name"
refers to an entity defined in the current local namespace.
It returns false otherwise.

...is_global

	bool is_global(string name)

The is_global function returns true if the argument "name"
refers to an entity defined in the global namespace. It
returns false otherwise.

...cast_to

	mixed cast_to(mixed x, string type)

The cast_to function returns a cast of the value "x" to the
datatype given as "type", using the same names as returned
by the typeof function. It is a fatal error to pass an
unknown type.

...set

	bool set(string name, mixed val)

The set function sets the variable named by the argument "name"
to the value given by the argument "val". It returns true
if the operation is successful or false if the name is not
a valid variable name.

...get

	mixed get(string name)

The get function returns the value of the variable named by
the "name" argument. If the name is not a valid variable
name or no variable of that name is defined, the get function
returns void.

...get_static

	mixed get_static(string cls, string name)

The get_static function returns a value from a structure
class, using "cls" as the class name and "name" as
the name of the struct element to return. It returns
void if the named structure class does not exist or
does not have a member of the given name.

...unset

	void unset(forced string name, ...)

The unset function removes entities from the current local
namespace, using all its arguments as entity names. Note
that removing names from the local namespace will make
entities from the global namespace visible again if they
were obscured by the local names. Global entities can
only be removed by a call to unset from top-level scope.

Note that at top-level scope, it is possible to unset
standard library variables and functions.

...global

	void global(forced string name, ...)

The global function uses all its arguments as variable
names. It copies the named variables from the current
local namespace to the global namespace.

...assert

	void assert(forced bool x, ...)

The assert function casts all its argument values to
type bool and then exits the running script with an
"assertion failure" message if at least one of the
expressions yields a false value. If all input values
are true, the assert function does nothing.

This function is mainly used for debugging and input
sanity checking.

...versions

	struct versions()

The versions function accepts no arguments and returns a
struct containing version numbers for the current Intend
C interpreter. The following fields are defined:

	major    Major version number
	minor    Minor version number
	release  Release version number
	version  Complete version string

Future versions of the Intend C interpreter are guaranteed
to always define a versions function with the behaviour
defined above.

..String functions

The string functions provide ways to manipulate strings and
check some properties of strings.

...sprintf

	string sprintf(string fmt, ...)

The sprintf function takes a format string fmt and additional
arguments that are formatted according to the format string.
The format string consists of normal characters and conversion
specifiers. A conversion specifier starts with the character
"%" (percent sign), followed by optional conversion flag
characters, followed by an optional field width, followed by
an optional precision, followed by a type specifier. For each
conversion specifier, one additional argument should be passed
into the sprintf function. Missing values are filled up with
void values. Each conversion specifier consumes one argument,
which is then formatted according to the specifier. The return
value of sprintf is a string with all non-specifier characters
from the format string copied over and all conversion
specifiers replaced by the result of formatting their
corresponding argument.

The following conversions flag characters are defined:

	0      zero-pad the value
	-      left-adjust the value
	       (space) put a blank before positive numbers
	+      always but a sign before a number

The field width specifies how many characters the conversion
result will use as a minimum. If the field width is larger
than needed, the default is to right-adjust the value using space
characters. If the field width is smaller than needed, the
result will still be as wide as necessary for the printed
value.

The precision, if present, needs to be given as a "." (period)
character followed by an optional decimal digit string. For
integer conversions, the precision specifies the minimum
number of digits to print. For float conversions, the precision
specifies how many digits to print after the decimal dot. For
string conversions, the precision specifies the maximum number
of characters to print from the string. If the decimal digit
string is missing, the precision is taken to be 0 (zero).

The type specifier, which must be present, defines which
type of argument value is expected by the conversion. If the
actual sprintf argument does not have the expected type,
a cast to that type is generated before use. The following
type specifiers are defined:

	d      int, print in decimal
	i      int, print in decimal
	f      float
	o      int, print in octal
	s      string
	x      int, print in lower-case hexadecimal
	X      int, print in upper-case hexadecimal

It is possible to include a percent character in the output
by using the special conversion specifier "%%" (double percent
sign).

The result of passing an invalid or malformed conversion
specifier into sprintf is undefined.

To give an example, the following sprintf invocation assigns
the string "00012.30 is here" to the variable "x":

	x = sprintf("%08.2f is here", 12.3);

...strlen

	int strlen(forced string x)

The strlen function returns the number of bytes contained in
its argument string.

...strcat

	string strcat(mixed x, ...)

The strcat function converts all its arguments to string and
returns a string containing the concatenation of the resulting
string values.

...strchr

	mixed strchr(forced string hay, forced string needle)

The strchr function searches for the leftmost occurrence of
the first character of the "needle" argument in the "hay"
argument. Character positions are counted from 0 (zero). If
the character is not found, void is returned.

...strrchr

	mixed strrchr(forced string hay, forced string needle)

The strrchr function searches for the rightmost occurrence of
the first character of the "needle" argument in the "hay"
argument. Character positions are counted from 0 (zero). If
the character is not found, void is returned.

...strstr

	mixed strstr(forced string hay, forced string needle)

The strstr function searches for the leftmost occurrence of
the string "needle" inside the string "hay". Character
positions are counted from 0 (zero). If the substring is not
found, void is returned.

...strspn

	int strspn(forced string hay, forced string set)

The strspn function returns the number of leading characters
of the string "hay" that are contained in the set of
characters defined by the string "set".

...strcspn

	int strcspn(forced string hay, forced string set)

The strspn function returns the number of leading characters
of the string "hay" that are not contained in the set of
characters defined by the string "set".

...strpbrk

	mixed strpbrk(forced string hay, forced string set)

The strpbrk function returns the position of the first
character in the string "hay" that is contained in the set
of characters defined by the string "set". Character
positions are counted from 0 (zero). If no matching
character is found, void is returned.

...strcoll

	int strcoll(forced string a, forced string b)

The strcoll function compares the strings "a" and "b"
according to the current locale (language) settings of
the operating system. It returns a negative int value
if "a" is found to be smaller than "b". It returns 0 (zero)
if "a" and "b" are found to be equal. It returns a
positive int value if "a" is found to be larger than "b".

...tolower

	string tolower(forced string x)

The tolower function returns a copy of its input string
with all upper-case letters converted to lower case.

...toupper

	string toupper(forced string x)

The toupper function returns a copy of its input string
with all lower-case letters converted to upper case.

...isalnum

	bool isalnum(forced string x)

The isalnum function returns true if its input string
contains only alphanumeric characters. This means only
letters and decimal digits are allowed. It returns false
otherwise.

...isalpha

	bool isalpha(forced string x)

The isalpha function returns true if its input string
contains only letters of the alphabet. It returns false
otherwise.

...iscntrl

	bool iscntrl(forced string x)

The iscntrl function returns true if its input string
contains only control characters; that is characters
with an ASCII value below 32. It returns false otherwise.

...isdigit

	bool isdigit(forced string x)

The isdigit function returns true if its input string
contains only decimal digits. It returns false otherwise.

...isgraph

	bool isgraph(forced string x)

The isgraph function return true if its input string
contains only graphical characters; that is no control
characters and no spaces. It returns false otherwise.

...islower

	bool islower(forced string x)

The islower function returns true if its input string
contains only lower-case letters. It return false
otherwise.

...isprint

	bool isprint(forced string x)

The isprint function returns true if its input string
contains only printable characters; that is no control
characters. It returns false otherwise.

...ispunct

	bool ispunct(forced string x)

The ispunct function returns true if its input string
contains only punctuation characters; that is no control
characters, no spaces, and no alphanumeric characters.
It returns false otherwise.

...isspace

	bool isspace(forced string x)

The isspace function returns true if its input string
contains only whitespace characters. Whitespace characters
are space, form-feed, newline, carriage return, horizontal
tab, and vertical tab. The isspace function returns false
if other characters are found in the input string.

...isupper

	bool isupper(forced string x)

The isupper function returns true if its input string
contains only upper-case letters. It returns false otherwise.

...isxdigit

	bool isxdigit(forced string x)

The isxdigit function returns true if its input string
contains only hexadecimal digits. It returns false
otherwise.

...substr

	string substr(forced string x, int pos)

The substr function, when called with two arguments, returns
a substring of the string "x" starting at character position
"pos". Character positions are numbered starting from 0 (zero).
If the position exceeds the number of characters in the input
string, an empty string is returned.

	string substr(forced string x, int pos, int max)

When called with three arguments, the "max" argument is used
as a maximum length for the returned substring. Excess
characters from the original string are not copied.

...left

	string left(forced string x, int max)

The left function returns the leftmost "max" characters from
the string "x", or less if the string "x" does not have
enough characters.

...right

	string right(forced string x, int max)

The right function returns the rightmost "max" characters from
the string "x", or less if the string "x" does not have
enough characters.

...ord

	mixed ord(forced string x)

The ord function returns the ASCII code of the first character
of the string "x" as an int value. If "x" is an empty string,
void is returned. If the first character of "x" is not a
7-bit ASCII character, the result is architecture dependant;
however, the result must be compatible with the chr function.

...chr

	string chr(int x)

The chr function returns a one-character string containing the
character with the ASCII value "x". If the input value does
not describe a 7-bit ASCII character, the result is architecture
dependant; however, the result must be compatible with the ord
function.

...explode

	array explode(forced string input)

The explode function converts the input string to an array,
so that the resulting array has one element for each character
of the original string. Each element will contain one original
character in the form of a single-character string.

...implode

	string implode(array input)

The implode function converts the input array into a string.
Each element of the input array is converted to a string
and the concatenation of all these is the return value of the
implode function.

The implode function can be used to reverse the effects of
the explode function.

...ltrim

	string ltrim(forced string input)

The ltrim function returns a copy of the input string with
all leading whitespace characters removed.

...rtrim

	string rtrim(forced string input)

The rtrim function returns a copy of the input string with
all trailing whitespace characters removed.

...trim

	string trim(forced string input)

The trim function returns a copy of the input string with all
leading and trailing whitespace characters removed.

..Array functions

The array functions are used to construct and manipulate array
values.

...mkarray

	array mkarray(mixed x, ...)

The mkarray function creates an array that contains all
the argument values. It is allowed to call mkarray with
no arguments at all, in which case the returned array
value is an empty array.

...qsort

	array qsort(array x)

The qsort function returns a sorted copy of the input
array. Element values are compared as if the
"smaller or equal" operator were used. The resulting
order may be uncertain if the array contains values
of different types.

...is_sorted

	bool is_sorted(array x)

The is_sorted function returns true if the input array is
sorted, according to the same condition that the qsort
function uses to sort an array. The result is false if the
input array is not sorted.

...array_unset

	array array_unset(array x, int index)

The array_unset returns a copy of the input array "x", with
the element at position "index" replaced by a void value.
The number of elements in the array or their indices do not
change.

...array_compact

	array array_compact(array x)

The array_compact function returns a copy of the input array
with all void values removed. The result is an array with the
minimum size needed to hold all non-void values from the
input array.

...array_search

	mixed array_search(array hay, mixed needle)

The array_search function searches the input array "hay" for
an element matching the value "needle", using the same rules
as the "==" operator. It returns the integer index of the
matching element or void if no matching element is found.

...array_merge

	mixed array_merge(mixed x, ...)

The array_merge function casts all its arguments to array
and then merges all these into a single large array value
that is returned. The merged array first contains all the
elements from the first argument array in their original
order, followed by the elements from the second array, and
so on until all arguments are consumed.

...array_reverse

	array array_reverse(array x)

The array_reverse function returns a copy of the input
array "x" with the order of the elements reversed.

..Structure functions

The structure functions are used to construct, inspect, and
manipulate struct values.

...mkstruct

	struct mkstruct(mixed key, mixed val, ...)

The mkstruct function constructs a struct value from its
argument values. The first argument is cast to string
and used as a field name. The value for that field is
taken from the second argument. The same principle is
used for the remaining arguments. If the number of
arguments is odd, a void value is used as value for the
last field.

...struct_get

	mixed struct_get(struct x, string field)

The struct_get function returns the value of the field
named "field" in the struct value "x". It returns void
if the field name does not exist in the struct value.

...struct_set

	struct struct_set(struct x, string field, mixed val)

The struct_set function adds a field called "field" to the
input struct "x". The new field value is given by the "val"
argument. The modified struct value is returned.

...struct_unset

	struct struct_unset(struct x, string field)

The struct_unset function returns a copy of the input struct
value "x", with the field named "field" removed from the
struct. It is not an error if no such field exists in the
input struct.

...struct_fields

	array struct_fields(struct x)

The struct_fields function returns an array of strings that
contains the names of all fields in the input struct that are
not of type fn.

...struct_methods

	array struct_methods(struct x)

The struct_methods function returns an array of strings that
contains the names of all fields in the input struct that
are of type fn.

...is_field

	bool is_field(struct x, string name)

The is_field function returns true if the field "name" exists
in the input struct "x" and its value is not of type fn. It
returns false otherwise.

...is_method

	bool is_method(struct x, string name)

The is_method function returns true if the field "name exists
in the input struct "x" and its value is of type fn. It
returns false otherwise.

...struct_merge

	struct struct_merge(mixed x, ...)

The struct_merge function casts all its arguments to struct
and then merges the resulting struct values. This is done so
that values of the same name in later arguments overwrite the
fields from earlier arguments (arguments being considered from
left to right, as usual). This function will merge both
fields and methods.

..Functions on functions

This group of functions provides ways to deal with values
of type fn.

...is_builtin

	bool is_builtin(fn f)

The is_builtin function returns true if the given function
has been defined by the language implementation itself, for
example as part of the standard library or a module. It
returns false otherwise.

This function can be used to check whether a standard
library function has been overwritten by a user-defined
function of the same name.

...is_userdef

	bool is_userdef(fn f)

The is_userdef function returns true if the given function
has been defined by the running script or any of its
included files. It returns false otherwise.

...function_name

	string function_name(fn f)

The function_name function returns the name of the function
contained in the given function value. For anonymous functions,
it returns a string composed of a backslash character followed 
by the string "lambda".

...call

	mixed call(fn f, ...)

The call function executes a function call. It behaves as
if the function "f" had been called with the rest of the
arguments as its arguments. It returns the return value
of "f".

...call_array

	mixed call_array(fn f, array args)

The call_array function executes a function call. It
behaves as if the function "f" had been called with the
arguments given in the array "args". It returns the return
value of "f".

...call_method

	mixed call_method(fn f, struct s, ...)

The call_method function executes the function "f" with
an additional local variable called "this" that contains
a copy of the struct value "s". The remaining arguments
are used as arguments to "f". The return value is the
return value of "f".

Note that in contrast to a normal method call, any
modifications to "this" inside of the function body of
"f" are not copied back to the struct "s".

...call_method_array

	mixed call_method_array(fn f, struct s, array args)

The call_method_array function executes the function "f"
with an additional local variable called "this" that
contains a copy of the struct value "s".  The array argument
"args" is used as arguments to "f". The return value is the
return value of "f".

Note that in contrast to a normal method call, any
modifications to "this" inside of the function body of
"f" are not copied back to the struct "s".

...prototype

	struct prototype(fn f)

The prototype function returns a struct describing the
prototype of the input function "f". The result struct
contains an element "ret" that describes the return
value of "f", and an element "args" that describes the
expected arguments of "f".

Types are described by using a two-element struct
containing the fields "type" and "force". The "type"
field contains a type name string as returned by the
typeof library function. The "force" field contains
bool true if the "forced" keyword was used in the
definition of the return value or argument in question.
It contains false otherwise.

The "ret" element of the return struct of the prototype
function directly contains a type description struct
as detailed above. The "args" element contains an
array of such descriptions, with the array element
at index 0 (zero) corresponding to the first argument
of the described fn value.

...map

	array map(fn f, array x, ...)

The map function applies the function "f" to each element of
the array "x" with the rest of the arguments being passed on
to "f". The return values of "f" are collected into a new
array which is returned from the map function.

...filter

	array filter(fn f, array x, ...)

The filter function applies the function "f" to each element
of the array "x" with the rest of the arguments being passed
on to "f". The return value of "f" is then cast to bool. If
the result is true, the element of "x" in question is copied
to the output array.

...foldl

	mixed foldl(fn f, mixed init, array x, ...)

The foldl function applies the function "f" to the array
"x" -- with the rest of the arguments following "x" being
passed on to "f" -- so that the array is reduced to a single
value. The value "init" is appended to the left of the array
and the values of the array are processed from left to
right, so that "f" is applied as follows, where "x0" means
the first element of the input array, "x1" the second
element, and "xn" the last element of the input array;
"args" denotes the arguments following "x" in the call to
foldl:

	f(f(f(f(init, x0, args), x1, args), ... ), xn, args)

If the input array is empty, the argument value "init" is
returned. Note that the construction of foldl requires that
the function "f" accepts values from the input array as
its second argument and its own return value as its first
argument. The value "init" must also be acceptable as a
first argument to "f".

...foldr

	mixed foldr(fn f, array x, mixed init, ...)

The foldr function applies the function "f" to the array
"x" -- with the rest of the arguments following "init" being
passed on to "f" -- so that the array is reduced to a single
value. The value "init" is appended to the right of the
array and the values of the array are processed from right
to left, so that "f" is applied as follows, where "x0" means
the first element of the input array, "x1" the second
element, and "xn" the last element of the input array;
"args" denotes the arguments following "init" in the call to
foldr:

	f(x0, f(x1, f(..., f(xn, init, args), args), args), args)

If the input array is empty, the argument value "init" is
returned. Note that the construction of foldr requires that
the function "f" accepts values from the input array as
its first argument and its own return value as its second
argument. The value "init" must also be acceptable as a
second argument to "f".

...take_while

	array take_while(fn f, array input, ...)

The take_while function applies the function "f" to the
elements of the array "input" with the rest of the arguments
being passed on to "f". The return value is cast to
bool. Elements are copied to the output array as long as
the result of "f" is true. Copying stops on the first
element of "input" that makes "f" return false.

...drop_while

	array drop_while(fn f, array input, ...)

The drop_while function applies the function "f" to the
elements of the array "input" with the rest of the arguments
being passed on to "f". The return value is cast to bool.
Elements are skipped as long as the return value of "f" is
true. Starting from the first element that makes "f" return
false elements are copied to the output array.

..Random number functions

The following functions provide a simple pseudo-random
number generator.

...RAND_MAX

	RAND_MAX

The int variable RAND_MAX is automatically set by the library
to contain the highest integer number that the random number
generator can produce.

...rand

	int rand(int min, int max)

The rand function generates a random number between the
lower bound "min" and the upper bound "max", inclusive.
The effect of negative bounds is architecture dependant.

If the lower bound exceeds RAND_MAX, the lower bound is
returned. If the upper bound exceeds RAND_MAX, it is
clipped to RAND_MAX before use.

If the random number generator was not seeded prior to
the first call to rand, a random seed based on the
current date and time is automatically generated.

...srand

	void srand(int seed)

The srand function seeds the pseudo-random generator with
the seed value "seed".

..Environment functions

The environment functions provide a limited way for a script
to deal with its execution environment.

...exit

	void exit(int status)

The exit function stops execution of the script and reports
the integer return value "status" to the operating system or
the host program. The exit function does not return to the
script.

...getenv

	mixed getenv(string name)

The getenv function searches the execution environment for
an environment variable with the given name. If such an
environment variable exists, its value is returned in the
form of a string value. If not, void is returned.

...setenv

	bool setenv(string name, string value)

The setenv function sets the execution environment variable
with the given name to the given value. If running in safe
mode, environment write is restricted so false is returned
and a warning is issued. If not, returns true if the
operation succeeded or false otherwise.

...unsetenv

	void unsetenv(string name)

The unsetenv function removes the execution environment
variable with the given name. If running in safe mode,
environment write is restricted so the operation is not
performed and a warning is issued.

..Date and time functions

The date and time functions provide a way to query the
operating system for the current date and time. There
are also function to create string representations of
dates and/or times.

...Date and time structure

Most of the date and time functions return or accept time
given as a struct value with the following fields, all
containing int values:

	tm_sec       seconds (0-59)
	tm_min       minutes (0-59)
	tm_hour      hours (0-23)
	tm_mday      day of month (1-31)
	tm_mon       month (0-11, 0 = January)
	tm_year      year (number of years since 1900)
	tm_wday      day of week (0-6, 0 = Sunday)
	tm_yday      day of year (0-365)
	tm_isdst     daylight savings (1 = yes)

The tm_sec field can actually have the range 0-61 to allow
for leap seconds.

...time

	int time()

The time function returns the number of seconds that have
passed since midnight on 1970-01-01 (the Unix time epoch).

...gmtime

	struct gmtime(int seconds)

The gmtime function returns a date and time struct as
described above. The struct contains the time equivalent
to the given number of seconds measured since the Unix
time epoch for the UTC time zone.

...localtime

	struct localtime(int seconds)

The localtime function returns a date and time struct as
described above. The struct contains the time equivalent
to the given number of seconds measured since the Unix
time epoch for the local time zone, as defined by the 
operating system.

...mktime

	int mktime(struct datetime)

The mktime function takes the date and time structure
"datetime" and returns the corresponding number of seconds
since midnight on 1970-01-01 (the Unix time epoch).

The result is undefined if the given struct is not a valid
date and time struct.

...asctime

	string asctime(struct datetime)

The asctime function returns a string containing an ASCII
representation of the time given by the date and time
structure "datetime". The format used by asctime results
in strings like "Wed Jun 30 21:49:08 1993\n", that is it
uses English three-letter abbreviations for the day of
the week and the month; it also terminates the string
with a newline character.

The result is undefined if the given struct is not a valid
date and time struct.

...ctime

	string ctime(int seconds)

The ctime function interprets its "seconds" arguments as
the number of seconds that have passed since midnight on
1970-01-01 (the Unix time epoch) in the local time zone.
It returns a string containing an ASCII representation of
that date and time in the same format as the asctime
function.

The result is undefined is the given number of seconds
is negative.

...strftime

	string strftime(string format, struct when)

The strftime function formats the date given by the date
and time structure "when" according to the format string
"format". The format string can contain conversion
specifiers starting with a "%" (percent sign) character
and other characters. Conversion specifiers are expanded
in the output string while all other characters are
copied to the output string unmodified. The following
conversion specifiers are defined:

	%%     literal percent sign
	%a     abbreviated weekday name
	%A     full weekday name
	%b     abbreviated month name
	%B     full month name
	%c     preferred date and time
	%d     day of month (01-31)
	%H     hour on 24-hour clock (00-23)
	%I     hour on 12-hour clock (01-12)
	%j     day of year (001-366)
	%m     month (01-12)
	%M     minute (00-59)
	%p     AM or PM (upper case)
	%S     second (00-61)
	%U     week number (00-53, Sunday first)
	%w     day of week (0-6, 0 = Sunday)
	%W     week number (00-53, Monday first)
	%x     preferred date format without time
	%X     preferred time format without date
	%y     year without century (00-99)
	%Y     year with century
	%Z     time zone name or abbreviation

The target architecture may define additional conversions.

..Locale functions

The locale functions provide a way to query and set the
operating system locale. This usually has an influence
on the language, date and time formats, and numerical
formats used by the operating systems and some standard
library functions.

The following is a table of standard library functions
that can be influenced by the current locale setting of
the operating system:

	strcoll  tolower  toupper  isalnum   isalpha
	islower  ispunct  isupper  strftime  strerror

...getlocale

	string getlocale()

The getlocale function returns the name of the currently
active operating system locale. It is expected that the
returned name is a valid argument for the setlocale function.

...setlocale

	mixed setlocale(string locale)

The setlocale function attempts to set the current
operating system locale to "locale". What names are valid
depends on the operating system being used. The setlocale
function returns the name of the new effective locale as a
string value on success, or void on failure.

Passing an empty string to setlocale instructs the
operating system to switch to the user's preferred
locale.

...localeconv

	struct localeconv()

The localeconv function returns a struct containing the
numerical formatting conventions of the current operating
system locale. The following fields are expected to be
set:

	decimal_point
	thousands_sep
	grouping
	int_curr_symbol
	currency_symbol
	mon_decimal_point
	mon_thousands_sep
	mon_grouping
	positive_sign
	negative_sign
	int_frac_digits
	frac_digits
	p_cs_precedes
	p_sep_by_space
	n_cs_precedes
	n_sep_by_space
	p_sign_posn
	n_sign_posn

All values are strings. Some strings are actually vectors
of integers, meaning they contain sequences of integers
between 0-9 which are encoded as ASCII characters of the
same value.

The "decimal_point" field indicates the decimal point
character to use for non-monetary values.

The "thousands_sep" field indicates the separator
characters to place between groups of digits before a
decimal point. It should only be used for non-monetary
values.

The "grouping" field indicates how to group digits
before a decimal point in non-monetary values. It is
a vector of bytes indicating how much digits to put
in each group. If the vector terminates with a
character of value 255, no further grouping is to take
place beyond that specified. If the vector does not
terminate with a 255 character, the last grouping given
is to be repeated for all remaining digits. For example,
assuming a "thousands_sep" of "," (comma), a string containing
the byte vector (3,2,3) means to print numbers like this:
"300,00,000".

The "int_curr_symbol" field specifies the standardised
international currency symbol to use for monetary values.

The "currency_symbol" field specifies the local currency
symbol to use for monetary values.

The "mon_decimal_point", "mon_thousands_sep", and
"mon_grouping" fields behave the same as their cousins
with the "mon_" prefix stripped, but they specify the
same information for monetary values.

The "positive_sign" field specifies the symbol to be used
to indicate positive monetary values.

The "negative_sign" field specifies the symbol to be used
to indicate negative monetary values.

The "int_frac_digits" field specifies how many digits to
print after the decimal point in international-style
monetary values.

The "frac_digits" field specifies how many digits to print
after the decimal point in local-style monetary values.

The "p_cs_precedes" field contains a character of value
1 (one) if the currency symbol should precede positive
monetary values. In any other case, the currency symbol
should follow positive monetary values.

The "p_sep_by_space" field contains a character of value
1 (one) if a space character should be placed between
the currency symbol and a positive monetary value. In
any other case, no space character is desired.

The "n_cs_precedes" and "n_sep_by_space" fields work
like the two preceding fields, but contains the information
for formatting negative monetary values.

The "p_sign_posn" field specifies where to place the
sign of positive monetary values with respect to the
currency symbol. An empty string specifies to put
parenthesis around the whole monetary string. The
following table lists the other possibilities:

	\x01    before the whole string
	\x02    after the whole string
	\x03    just before currency symbol
	\x04    just after currency symbol

The "n_sign_posn" field works like the "p_sign_posn"
field, but gives information for negative monetary values.

Any field may contain a one-byte string with a byte of
value 255 to indicate that the field is not available in
the current locale.

Note that the accuracy and availability of the above
information depends entirely on the operating system being
used.

..Modules functions

This part of the library implements the functionality to
load, unload and check if modules are loaded.

Loading or unloading modules is restricted in safe mode.
Only pre-loaded modules are allowed in safe mode.

...module_is_loaded

	bool module_is_loaded(string modname)

This function checks if the module is loaded or pre-loaded.
Returns true if the module is loaded or pre-loaded, otherwise
returns false.

...module_load

	void module_load(string modname, ...)

This function loads the modules passed as arguments. It accepts a
list of module names. If in safe mode or if something went wrong
this function throws an exception.

...module_unload

	void module_unload(string modname, ...)

This function unloads the modules passed  as arguments. It accepts a
list of module names. If in safe mode or if something went wrong
this function throws an exception.

.Modules

What about the modules Intend C includes? In this chapter you
find a description of all the modules that are present in the
Intend C Core distribution, and also some contributor modules
that were tested to be trustfull and incorporated in the main
trunk of Intend C.

The modules that are included with Intend C distribution are
as follows:

..Console I/O module ("console")

The Console I/O module can be used to provide human-readable
output from a script or retrieve input from the user.

...Functions

....getc

	string getc()

The getc function reads a character from the standard input
and returns it in a string.

....getchar

	string getchar()

This function is an alias of getc function described before.

....gets

	string gets()

The gets function reads a text line from the standard input
and returns it in a string.

Don't forget that this function also returns the '\n' at the
end of the line.

Also, if the standard input is redirected to a binary stream
this function will return a string up to 64K of binary
characters.

....input

	string input()

This function is an alias of gets function described before.

....print

	void print(mixed x, ...)

The print function casts all of its arguments to string and
outputs the resulting strings end-to-end, without intervening
whitespace.

....puts

	void puts(mixed x, ...)

This function is an alias of print function described before.

....dump

	void dump(mixed x, ...)

The dump function outputs a dump of all its argument values.
For each value, the type and a string representation of the
actual value are printed.

This function is mainly intended for debugging purposes.

....printf

	void printf(string fmt, ...)

The printf function takes a format string fmt and additional
arguments that are formatted according to the format string
and output to the standard output.

The format string consists of normal characters and conversion
specifiers. A conversion specifier starts with the character
"%" (percent sign), followed by optional conversion flag
characters, followed by an optional field width, followed by
an optional precision, followed by a type specifier. For each
conversion specifier, one additional argument should be passed
into the printf function. Missing values are filled up with
void values. Each conversion specifier consumes one argument,
which is then formatted according to the specifier. The output
of printf is a string with all non-specifier characters from
the format string copied over and all conversion specifiers
replaced by the result of formatting their corresponding
argument.

The following conversions flag characters are defined:

	0      zero-pad the value
	-      left-adjust the value
	       (space) put a blank before positive numbers
	+      always put a sign before a number

The field width specifies how many characters the conversion
result will use as a minimum. If the field width is larger
than needed, the default is to right-adjust the value using
space characters. If the field width is smaller than needed,
the result will still be as wide as necessary for the printed
value.

The precision, if present, needs to be given as a "." (period)
character followed by an optional decimal digit string. For
integer conversions, the precision specifies the minimum
number of digits to print. For float conversions, the precision
specifies how many digits to print after the decimal dot. For
string conversions, the precision specifies the maximum number
of characters to print from the string. If the decimal digit
string is missing, the precision is taken to be 0 (zero).

The type specifier, which must be present, defines which
type of argument value is expected by the conversion. If the
actual printf argument does not have the expected type,
a cast to that type is generated before use. The following
type specifiers are defined:

	d      int, print in decimal
	i      int, print in decimal
	f      float
	o      int, print in octal
	s      string
	x      int, print in lower-case hexadecimal
	X      int, print in upper-case hexadecimal

It is possible to include a percent character in the output
by using the special conversion specifier "%%" (double percent
sign).

The result of passing an invalid or malformed conversion
specifier into printf is undefined.

To give an example, the following printf invocation outputs
the string "00012.30 is here":

	printf("%08.2f is here", 12.3);

..Dictionary module ("dict")

The dictionary module provides a way to use dictionaries. A
dictionary associates string names with arbitrary values.
Dictionaries are represented by resource values, which are
cheap to pass into functions that need access to the
dictionary.

Implementations can limit the strings that are acceptable
as names for dictionary entries. For example, strings
containing characters of value 0 (zero) may not be
acceptable.

When the resource value of a dictionary is unset or the
namespace containing containing it is destroyed, the
memory associated with the dictionary is freed.

...Functions

....is_dict_resource

	bool is_dict_resource(resource res)

The is_dict_resource returns true if the resource "res"
is a dictionary resource. It returns false otherwise.

....dopen

	mixed dopen(int order)

The dopen function creates a new, empty dictionary
and returns a resource for the new dictionary. The "order"
parameter specifies a power of two that gives the
average number of elements that the programmers expects
to put into the dictionary. Thus, an order of 5 means
an expected average of 32 elements in the dictionary.
The order is only a hint that can be used to decide on
an appropriate internal representation of the dictionary.

The dopen function returns void if the new dictionary
could not be created, for example when not enough free
memory is available.

....dread

	mixed dread(resource handle, string name)

The dread function looks for an entry with the given name
in the dictionary associated with the handle "handle". If
the entry is found, its value is returned. Otherwise,
void is returned.

....dwrite

	bool dwrite(resource handle, string name, mixed value)

The dwrite function creates a new entry in the dictionary
associated with the handle "handle". The name for the
new entry is "name" and the value is "value". If the
dictionary already contains an entry for the same name,
the old entry is discarded.

The dwrite function returns true on success or false if
the handle is invalid or the name is not an acceptable
dictionary entry name.

....dremove

	bool dremove(resource handle, string name)

The dremove function removes the entry with the given name
from the dictionary associated with the handle "handle".
Subsequent reads from the dictionary using the name will
return void.

The dremove function returns true on success or false if
the handle is invalid or the name not an acceptable
dictionary entry name.

....dexists

	bool dexists(resource handle, string name)

The dexists function returns true if the given name exists
in the dictionary associated with the handle "handle". It
returns false if no such entry is found in the dictionary.

....dclose

	void dclose(resource handle)

The dclose function closes the dictionary associated with
the handle "handle". All memory used by the dictionary is
released. 

Use of the resource value after calling dclose behaves
as if the resource is not a valid dictionary resource.

..Dynamic Library Loading module ("dyn")

This module provides functions that allow an Intend C script
to dynamically load C libraries and call C functions contained
in those libraries. Foreign function calls are not necessarily
possible on all operating systems and architectures supported
by an Intend C interpreter.

Care needs to be taken when calling C functions that use
pointers. Intend C cannot automatically manage memory for
called C functions, so it is the responsibility of the
programmer to allocate and free memory used for calls into
C library functions. This can be done by using the dynamic
memory allocation module described in the respective section.

NOTE: Be aware that this module does not filter any access if
running in safe mode and that it is not recommended the use of
this module in safe mode environments.

...Functions

....is_dyn_resource

	bool is_dyn_resource(resource res)

The is_dyn_resource returns true if the resource "res"
is a resource for a loaded dynamic library. It returns false
otherwise.

....dyn_open

	mixed dyn_open(string name)

The dyn_open function tries to dynamically load the C library
called "name". What names constitute valid library names
depends on the operating system in use. On Unix systems, is
is normally possible to specify both an absolute path and
a relative one. Relative paths are then searched for in a
set of pre-defined library directories.

On success, the dyn_open function returns a resource that
represents the loaded library. On failure, dyn_open returns
void.

....dyn_close

	void dyn_close(resource lib)

The dyn_close function tries to unload the C library represented
by the resource "lib". Whether the library actually is unloaded
from memory depends on the operating system used. In any case,
the resource is no longer usable as a valid library resource.

....dyn_fn_pointer

	mixed dyn_fn_pointer(resource lib, string name)

The dyn_fn_pointer function searches the library pointed to
by the resource "lib" for a function called "name". If it
is found, a memory resource pointing to the function is
returned. This memory resource has an unknown size and is
read-only. If "lib" is not a valid library resource or the
function "name" is not found, void is returned.

This function is mainly useful for creating memory resources
that can be passed into C function that expect function
pointers.

....cfloat

	mixed cfloat(forced float val)

The cfloat function converts the input float value "val" to
a representation that is suitable for directly passing into
C functions that expect the C "float" type for an argument.

Depending on the machine architecture, the cfloat function
will return either an int value or a float value. Some 
precision may be lost by the transformation.

....dyn_call_void

	void dyn_call_void(resource lib, string name, ...)

The dyn_call_void function tries to call a C function called
"name" from the library pointed to by the resource "lib". The
rest of the arguments are passed to the C function. The following
conversions take place for the arguments:

	Intend C type   C type
	void            int (zero)
	bool            int (0 or 1)
	int             long int
	float           double
	string          char *
	resource        void *

For resources, file resources created by the fopen function
are passed as "FILE *" pointers and memory resources are
passed as "void *" pointers. This does the right thing for
both types of resource. For other resources the conversion
is not meaningful.

Values of type void, int, bool, int, and float are passed
as copies. Values of type string and resource are passed
as pointer references, so the called C function can directly
access or even change their contents.

It is not allowed to directly pass arrays or structures into
C functions. You can use the memory management functions
to manually create in-memory representations of C arrays and
structures and pass them as resources.

If you need to pass a floating point value to a C function
that expects a C "float" and not a C "double" value as its
argument, you need to use the cfloat library function to 
convert the Intend C float value to a suitable representation 
first.

Note that the calling conventions on real-world architectures
normally specify to pass any C integer type as if it were
"long int". You still need to take care that you do not
overflow the range of the C integer type that the called C
function really expects.

The dyn_call_void function assumes that the called C function
does not return a value and thus returns void itself.

....dyn_call_int

	mixed dyn_call_int(resource lib, string name, ...)

The dyn_call_int function works almost exactly like the
dyn_call_void function, but assumes that the called C
function returns the C type "int" or a compatible, shorter
integer type such as "short" or "char". This value is
returned in the form of an Intend C int value. If the called
C function does not return an "int", the resulting int
value is undefined.

If the resource "lib" is not a valid library resource or
the function "name" cannot be found, void is returned.

....dyn_call_float

	mixed dyn_call_float(resource lib, string name, ...)

The dyn_call_float function works almost exactly like the
dyn_call_void function, but assumes that the called C
function returns the C type "double" or a compatible,
shorter floating point type such as "float". This value is
returned in the form of an Intend C float value. If the called
C function does not return a "double", the resulting float
value is undefined.

If the resource "lib" is not a valid library resource or
the function "name" cannot be found, void is returned.

....dyn_call_ptr

	mixed dyn_call_ptr(resource lib, string name, ..., bool free)

The dyn_call_ptr function works almost exactly like the
dyn_call_void function, but assumes that the called C
function returns a C pointer. This value is returned in
the form of an Intend C memory resource pointing at the same
memory as the C pointer. If the last argument to the
dyn_call_ptr function is "true", this memory is freed when
the memory resource is unset or goes out of scope. When
the last argument to dyn_call_ptr is not a bool value or
"false", the memory is not freed by the Intend C interpreter.

If the called C function does not return a pointer, the
resulting memory resource points at an undefined memory
location. In any case, the resulting memory resource has
an unknown size and is read-only.

If the resource "lib" is not a valid library resource or
the function "name" cannot be found, void is returned.

..Filesystem I/O module ("file")

The Filesystem I/O module provides a way to perform I/O
operations on filesystems. Files must be opened before
they can be used. Opening results in a file handle that
is encapsulated in a resource value.

Each file handle has four basic properties: buffering,
file position, error indicator, and end-of-file indicator.
Each of these can be queried and set by the functions
described below.

When the resource value of a file handle becomes unset
or the containing namespace is destroyed, the file handle
is closed. This writes all data that may still be
buffered in the file handle to disk.

The Filesystem I/O module also includes functions to
manipulate directories.

...Globals

This module defines the following global variables to use
with access modes and stat:

	S_IFMT   0170000  bit mask for the file type bit fields
	S_IFSOCK 0140000  socket
	S_IFLNK  0120000  symbolic link
	S_IFREG  0100000  regular file
	S_IFBLK  0060000  block device
	S_IFDIR  0040000  directory
	S_IFCHR  0020000  character device
	S_IFIFO  0010000  FIFO
	S_ISUID  0004000  set UID bit
	S_ISGID  0002000  set GID bit
	S_ISVTX  0001000  sticky bit
	S_IRWXU    00700  mask for file owner permissions
	S_IRUSR    00400  owner has read permission
	S_IWUSR    00200  owner has write permission
	S_IXUSR    00100  owner has execute permission
	S_IRWXG    00070  mask for group permissions
	S_IRGRP    00040  group has read permission
	S_IWGRP    00020  group has write permission
	S_IXGRP    00010  group has execute permission
	S_IRWXO    00007  mask for permissions for others
	S_IROTH    00004  others have read permission
	S_IWOTH    00002  others have write permission
	S_IXOTH    00001  others have execute permission

Use these variables as bit masks for file or directory modes.

...Functions

....is_file_resource

	bool is_file_resource(resource res)

The is_file_resource returns true if the resource "res"
is a file resource. It returns false otherwise.

....basename

	string basename(string path)

Returns the filename part of the path string supplied.
This function does not verify if path is valid.

....dirname

	string dirname(string path)

Returns the directory part of the path string supplied.
This function does not verify if path is valid.

....realpath

	string realpath(string path)

Returns the absolute path the supplied path refers to. This
function verifies if the path is valid and returns an empty
string if invalid.

....getcwd

	string getcwd()

Returns the current working directory. If running in safe mode
this operation is not allowed and the result will always be an
empty string.

....chdir

	bool chdir(string path)

Changes the current working directory to the supplied path.
Returns true if the change was successful, otherwise returns
false and errno is set appropriately (see system module). If
running in safe mode this operation is not allowed and the
result will always be false.

....mkdir

	bool mkdir(string path)
	bool mkdir(string path, int mode)

Creates the supplied directory. The optional mode is the octal
value for access rights, for instance 0777. If the mode is not
passed the default value of 0755 is used. Returns true if the
directory was successfuly created, otherwise returns false and
errno is set appropriately (see system module). If running in
safe mode this operation is restricted to sandboxed read/write
paths and it will return false if path is not valid.

....rmdir

	bool rmdir(string path)

Removes the supplied directory. Returns true if the directory
was successfuly removed, otherwise returns false and errno is
set appropriately (see system module). If running in safe mode
this operation is restricted to sandboxed read/write paths and
it will return false if path is not valid.

....stat

	mixed stat(string path)

Returns stat information about the path specified, either a file
or a directory, in a struct similar to the C stat standard
library. If the path doesn't exist, stat returns void. If
running in safe mode this operation is restricted to sandboxed
paths and it will return void if path is not valid.

The stat returned struct has the following fields:

	st_dev      device number
	st_ino      inode number
	st_mode     inode protection mode
	st_nlink    number of links
	st_uid      userid of owner
	st_gid      groupid of owner
	st_rdev     device type, if inode device
	st_size     size in bytes
	st_atime    time of last access (Unix timestamp)
	st_mtime    time of last modification (Unix timestamp)
	st_ctime    time of last inode change (Unix timestamp)
	st_blksize  blocksize of filesystem IO
	st_blocks   number of blocks allocated

Please see the C standard library for more detail about each
of the parameters.

All fields in the stat structure are of type int

....access

	bool access(string path, int mode)

This function checks whether the real user id can access
the file pathname. If pathname is a symbolic link, it is
dereferenced. The mode specifies the accessibility check(s)
to be performed, and is either the value F_OK, or a mask
consisting of the bitwise OR of one or more of R_OK, W_OK,
and X_OK. F_OK tests for the existence of the file. R_OK,
W_OK, and X_OK test whether the file exists and grants read,
write, and execute permissions, respectively. The function
returns true on successful access check and false otherwise
and errno is set appropriately.

....eaccess

	bool eaccess(string path, int mode)

This function checks whether the effective user id can access
the file pathname. If pathname is a symbolic link, it is
dereferenced. The mode specifies the accessibility check(s)
to be performed, and is either the value F_OK, or a mask
consisting of the bitwise OR of one or more of R_OK, W_OK,
and X_OK. F_OK tests for the existence of the file. R_OK,
W_OK, and X_OK test whether the file exists and grants read,
write, and execute permissions, respectively. The function
returns true on successful access check and false otherwise
and errno is set appropriately.

....umask

	int umask(int mask)

Sets the process file or directory creation mask to the value
supplied. The mask is the octal bit mask for the access rights,
for instance 0111. This will allow only to create files or
directories without the execute access. This fuction always
succeeds and the previous value of the mode is returned. If
running in safe mode this operation is not allowed and the
result will always be 0.

....fopen

	mixed fopen(string name, string mode)

The fopen function tries to open the file identified by "name"
with the I/O mode given by "mode". If the operation is
successful, a file handle resource is returned. If an error
occurs or the given mode is invalid, void is returned. If
running in safe mode this operation is restricted to sandboxed
read/write paths and it will return void if path is not valid.

The following modes are defined:

	r      open for reading
	r+     open for reading and writing
	w      open for writing
	w+     open for writing and reading
	a      open for appending
	a+     open for appending and reading

For "r" modes, it is an error if the file does not exist.
For "w" modes, the file will be created if it did not exist
and will be truncated to zero size if it did. For "a" modes,
the file will be created if it did not exist, but it will
not be truncated if it did.

The initial file position for "r" and "w" modes is the
beginning of the file. The initial file position for "a"
mode is the end of the file. Additionally, all writes in "a"
mode append data to the end of the file, irrespective of
the file position at the time of the write.

....fseek

	bool fseek(resource handle, int position)

The fseek function attempts to set the file position of the
file handle "handle" to "position". Positive positions are
taken to be from the start of the file, negative positions
are taken to be from the end of the file. The fseek function
returns true on success and false on failure.

The effects of setting the file position beyond the end
of the file are architecture dependant.

....ftell

	mixed ftell(resource handle)

The ftell function returns the current file position of the
file handle "handle". It returns the file position as an
int value on success or void on error.

If the current file position does not fit into an int value,
the result may be uncertain.

....fread

	mixed fread(resource handle, int max)

The fread function tries to read at most "max" bytes from the
file associated with the file handle "handle". It returns a
string containing the bytes read on success or void on
failure. It is not a failure if less than the given number of
bytes were available.

....fgetc

	mixed fgetc(resource handle)

The fgetc function tries to read one byte from the file
associated with the file handle "handle". It returns a string
containing the byte read on success or void on failure.

....fgets

	mixed fgets(resource handle)

The fgets function tries to read a single line of text
from the file associated with the file handle "handle". A line
is considered to end at the next newline character or the
end of the file. The fgets function returns the line read
as a string value, including the newline character, if any.
On failure, void is returned.

In order to ease the memory management burden, the architecture
may specify a maximum length for the returned string. In this
case, lines in the file that are longer than the defined maximum
length will be returned as multiple lines, but no synthetic
newline characters should be inserted.

....fwrite

	mixed fwrite(resource handle, string data)

The fwrite function tries to write the bytes contained in the
string "data" to the file associated with the file handle
"handle". It returns the number of bytes actually written or
void if "handle" is not a valid file handle. If an I/O error
occurs, the number of bytes written before the error occurred
is returned.

....setbuf

	bool setbuf(resource handle, bool enable)

The setbuf function can be called between opening a file and
performing the first I/O operation on the file handle. It
enables or disables buffering for the file handle "handle".
If "enable" is true, the file handle is block buffered with
a block size defined by the architecture. If "enable" is false,
the file handle is unbuffered, and all reads and writes will
go directly to the file.

The setbuf function returns true on success and false on
failure.

....fflush

	bool fflush(resource handle)

The fflush function flushes all buffers associated with the
file handle "handle", meaning all outstanding writes will be
written to the associated file before the fflush function
returns. It returns true on success and false on failure.

....feof

	bool feof(resource handle)

The feof function returns true if the end-of-file indicator
of the file handle "handle" is set. It returns false
otherwise. The end-of-file indicator is set whenever one
of the reading functions has previously encountered the
end of the associated file. If no read from the file handle
has taken place yet, feof always returns false.

....ferror

	bool ferror(resource handle)

The ferror function returns true if the error indicator of
the file handle "handle" is set. It returns false otherwise.
The error indicator is set whenever an I/O function used
on the file handle has encountered an I/O error. If no
operation on the file handle has taken place yet, ferror
always returns false.

....clearerr

	void clearerr(resource handle)

The clearerr function clears both the end-of-file and error
indicator of the file handle "handle".

....fclose

	bool fclose(resource handle)

The fclose function closes the file associated with the
file handle "handle", after which "handle" is no longer
associated with the file. If the file was buffered,
any pending data not yet written to the file is flushed
to disk.

The fclose function returns true on success and false
on failure. A failure can result if the file handle
was buffered and an I/O error occurred while flushing the
contents of the buffer to disk.

Use of the resource value after calling fclose behaves
as if the resource is not a valid file resource.

....link

	bool link(string path, string linkpath)

This function creates an hard link from linkpath to path. If
linkpath exists it will not be overwitten. The created linkpath
refers to the same file, so have the same permissions and
ownership, and it is impossible to tell which one was the
original. This function returns true on success and false
otherwise, and errno will be set appropriately.

....symlink

	bool symlink(string path, string linkpath)

This function creates a symbolic link from linkpath to path. If
linkpath exists it will not be overwitten. The created linkpath
acts like a shortcut to the path file, so its permissions and
ownership are irrelevant, and may point to non-existent files.
This function returns true on success and false otherwise, and
errno will be set appropriately.

....unlink

	bool unlink(string path)

This function deletes a name from the filesystem. If that name
was the last link to a file and no processes have the file open
the file is deleted and the space it was using is made
available for reuse. If the name was the last link to a file
but any processes still have the file open the file will remain
in existence until the last file descriptor referring to it
is closed. If the name referred to a symbolic link the link is
removed. This function returns true on success and false
otherwise, and errno will be set appropriately.

....remove

	bool remove(string name)

The remove function tries to remove the file with the
given name from disk. It returns true on success and false
on failure, and errno is set appropriately.

....rename

	bool rename(string source, string dest)

The rename function tries to rename the file with the path
given by "source" to the path given by "dest", moving the
file over directories if required. It returns true on
success and false on failure, and errno is set appropriately.

....copy

	bool copy(string source, string dest)

The copy function tries to copy the file with the path
given by "source" to the path given by "dest". It returns
true on success and false on failure, and errno is set
appropriately.

....scandir

	mixed scandir(string path)

The scandir function tries to read a directory path and return
an array of all files and directries found there. If succeded
this function returns an array, otherwise returns void.

....scandirs

	mixed scandirs(string path)

The scandir function tries to read a directory path and return
an array of all directries found there. If succeded this
function returns an array, otherwise returns void.

....scanfiles

	mixed scanfiles(string path)

The scandir function tries to read a directory path and return
an array of all files found there. If succeded this function
returns an array, otherwise returns void.

....fileread

	mixed fileread(string path)

This function reads the entire contents of a file to a string.
If some error occurs returns void and errno should have the 
error code if filesystem error, otherwise returns a string
with the result.

....filewrite

	bool filewrite(string content, string path)

This function writes the content of a string to a file. Returns
true if successful and false otherwise, setting errno with the
correspondent error code.

....filereadarray

	mixed filereadarray(string path)
	mixed filereadarray(string path, string delimiter)

This function reads the entire contents of a file to an array.
The array elements are separated by default when a '\n'
character is matched, but the desired delimiter can be passed
as a second argument. If some error occurs returns void and
errno should have the  error code if filesystem error,
otherwise returns an array with the result.

....filewritearray

	bool filewritearray(string content, string path)
	bool filewritearray(string content, string path,
	                    string delimiter)

This function writes the content of a string to a file. The
array elements are separated by default when a '\n' character
is matched, but the desired delimiter can be passed as a third
argument. Returns true if successful and false otherwise,
setting errno with the correspondent error code.

....pipe

	bool pipe(mixed &in, mixed &out)

The pipe function creates a pipe, opens both ends and returns
the in and out variables (passed by reference) with the file
resources. The in end is open for reading and the out end is
open for writing. After creating the pipe, functions fgets or
fwrite, among others can be used to write to the out end or
read from the in end of the pipe. The function returns true if
the pipe is created and false otherwise, setting errno with the
respective error code.


..List Management module ("list")

The list module provides a way to work with arrays that
makes them similar to the list datatypes found in functional
languages such as Standard ML or Haskell.

...Functions

....nil

	array nil()

The nil function returns an empty array.

....cons

	array cons(mixed head, array tail)

The cons function prepends the element "head" to the array
"tail" and returns the resulting array.

....length

	int length(array list)

The length function returns the number of elements that are
present in the input array.

....null

	bool null(array list)

The null function returns true if the input array is empty.
It returns false otherwise.

....elem

	bool elem(array list, mixed search)

The elem function returns true if the input array "list"
contains an element that equals the "search" argument, using
the same rules as the equality (==) operator. The elem
function returns false if no matching element is found.

....head

	mixed head(array list)

The head function returns the first element of the array
"list". If the input array is empty, the head function
returns a void value.

....tail

	array tail(array list)

The tail function returns a copy of the input array with
the first element removed.

....last

	mixed last(array list)

The last function returns the last element of the input
array, or a void value if the input array is empty.

....init

	array init(array list)

The init function returns a copy of the input array with
the last element removed.

....take

	array take(array list, int count)

The take function returns an array that contains the first
"count" elements from the input array "list". Less elements
are returned if the input array is not large enough.

....drop

	array drop(array list, int count)

The drop function returns a copy of the input array "list"
with the first "count" elements removed. If the input array
contains less than "count" elements, an empty array is
returned.

....intersperse

	array intersperse(array list, mixed elem)

The intersperse function inserts a copy of the value "elem"
between all the elements of the input array "list". If the
input array is empty or contains exactly one element, no new
elements are inserted.

....replicate

	array replicate(mixed elem, int count)

The replicate function returns an array of "count" elements,
each containing the value "elem". If the given count is zero
or negative, an empty array is returned.

..Math Functions module ("math")

The math module mostly work on float values and perform
mathematical computations.

...Functions

....exp

	float exp(forced float x)

The exp function computes the exponential of its input value.

....log

	float log(forced float x)

The log function computes the natural logarithm of its input
value.

....log10

	float log10(forced float x)

The log10 function computes the base 10 logarithm  of its
input value.

....sqrt

	float sqrt(forced float x)

The sqrt function computes the square root of its input value.

....ceil

	float ceil(forced float x)

The ceil function computes the smallest non-fractional number
that is larger than or equal to the input value.

....floor

	float floor(forced float x)

The floor function computes the largest non-fractional number
that is smaller than or equal to the input value.

....fabs

	float fabs(forced float x)

The fabs function computes the absolute value of its input
value.

....sin

	float sin(forced float x)

The sin function computes the sine of its input value.

....cos

	float cos(forced float x)

The cos function computes the cosine of its input value.

....tan

	float tan(forced float x)

The tan function computes the tangent of its input value.

....asin

	float asin(forced float x)

The asin function computes the arc-sine of its input value.

....acos

	float acos(forced float x)

The acos function computes the arc-cosine of its input value.

....atan

	float atan(forced float x)

The atan function computes the arc-tangent of its input value.

....sinh

	float sinh(forced float x)

The sinh function computes the hyperbolic sine of its input
value.

....cosh

	float cosh(forced float x)

The cosh function computes the hyperbolic cosine of its input
value.

....tanh

	float tanh(forced float x)

The tanh function computes the hyperbolic tangent of its input
value.

....abs

	int abs(forced int x)

The abs function computes the absolute value of its input value.

....fmod

	float fmod(forced float a, forced float b)

The fmod function computes the rest of the division of input
value a by input value b. This function is similar to the intern
operator %, but computes over a float division instead of int.

....powf

	float powf(forced float a, forced float b)

The powf function computes the power of base a and exponent b.
This function is similar to the internal operator **, but
computes a float power instead of int.

..Dynamic Memory Allocation module ("mem")

While Intend C does provide automatic memory management,
sometimes it is necessary to manually allocate and deallocate
memory. This is especially true for calling into C libraries
from an Intend C script (see "dyn" module), since these
will often need pointers to memory and you cannot let this
memory be automatically freed while the C library may still
be using it.

The memory management functions work with resources that
represent memory allocated from the operating system. Intend C
memory resources automatically expand as needed, so they
can't overflow when used from Intend C script code.

Memory resources can be read-write or read-only. Resources
created by an Intend C script are always writable, but
memory resources returned by calls to C functions are
normally read-only.

NOTE: Be aware that this module does not filter any access if
running in safe mode and that it is not recommended the use of
this module in safe mode environments.

...Functions

....is_mem_resource

	bool is_mem_resource(resource res)

The is_mem_resource returns true if the resource "res"
is a memory resource. It returns false otherwise.

....malloc

	mixed malloc(int size)

The malloc function allocates "size" bytes of memory. It
returns a memory resource on success and void on failure.
The contents of the allocated memory are undefined.

When the resulting memory resource is unset or goes out
of scope, the associated operating system memory is freed.

....calloc

	mixed calloc(int number, int size)

The calloc function allocates memory sufficient to store
"number" elements of "size" bytes each. The allocated memory
is always zero-filled. The calloc function returns a memory
resource on success and void on failure.

When the resulting memory resource is unset or goes out
of scope, the associated operating system memory is freed.

....realloc

	bool realloc(resource mem, int size)

The realloc function changes the size of the memory associated
with the memory resource "mem" to "size" bytes. When the
memory resource is extended, the contents of the newly allocated
bytes are undefined.

The realloc function returns true if the memory resource could
be resized successfully or false on failure. On failure, the
input memory resource retains its original size and contents.

....free

	void free(resource mem)

The free function frees up the operating system memory
associated with the resource "mem". Further attempts to
read or write the memory resource will fail.

....cnull

	resource cnull()

The cnull function returns a memory resource that is equivalent
to a NULL pointer in C. The resource points to no memory and
has a size of zero. It cannot be read or written by other
Intend C memory functions.

This function is mainly useful for creating a resource that
can be passed to a C function that expects a NULL pointer.

....is_null

	bool is_null(resource res)

The is_null function returns true if the resource "res" is a
memory resource that points to no memory. In this case, the
resource will act like a C NULL pointer when passed into a
call to a C function.

This function is mainly useful for checking memory resources
returned from C function calls.

....cstring

	mixed cstring(forced string x)

The cstring function creates a memory resource that contains
a C string (a sequence of characters terminated by a \0
character) that is a copy of the input string. The resulting
resource is returned.

The cstring function returns void when the input string
cannot be converted to a meaningful C string. This is the
case when the Intend C string contains embedded 0 (zero) bytes.

When the resulting memory resource is unset or goes out
of scope, the associated operating system memory is freed.

....mputchar

	bool mputchar(resource mem, int offset, int val)

The mputchar function stores a character into the memory
resource "mem", using "offset" as a byte offset from the start
of the memory resource. The input value "val" is truncated
to fit into a C "char" value and stored into the memory
resource. If the memory resource is smaller than needed by
the offset and stored value, it is expanded to fit.

The mputchar function returns true on success and false
on failure.

....mputshort

	bool mputshort(resource mem, int offset, int val)

The mputshort function stores a short integer into the memory
resource "mem", using "offset" as a byte offset from the start
of the memory resource. The input value "val" is truncated
to fit into a C "short" value and stored into the memory
resource. If the memory resource is smaller than needed by
the offset and stored value, it is expanded to fit.

The mputshort function returns true on success and false
on failure.

....mputint

	bool mputint(resource mem, int offset, int val)

The mputint function stores an integer into the memory
resource "mem", using "offset" as a byte offset from the start
of the memory resource. The input value "val" is truncated
to fit into a C "int" value and stored into the memory
resource. If the memory resource is smaller than needed by
the offset and stored value, it is expanded to fit.

The mputint function returns true on success and false
on failure.

....mputfloat

	bool mputfloat(resource mem, int offset, float val)

The mputfloat function stores a float value into the memory
resource "mem", using "offset" as a byte offset from the start
of the memory resource. The input value "val" is truncated
to fit into a C "float" value and stored into the memory
resource. If the memory resource is smaller than needed by
the offset and stored value, it is expanded to fit.

The mputfloat function returns true on success and false
on failure.

....mputdouble

	bool mputdouble(resource mem, int offset, float val)

The mputdouble function stores a float value into the memory
resource "mem", using "offset" as a byte offset from the start
of the memory resource. The input value "val" is converted
to a C "double" value and stored into the memory resource.
If the memory resource is smaller than needed by the offset
and stored value, it is expanded to fit.

The mputdouble function returns true on success and false
on failure.

....mputstring

	bool mputstring(resource mem, int offset, forced string s)

The mputstring function stores a string value into the memory
resource "mem", using "offset" as a byte offset from the start
of the memory resource. Each character from the input string "s"
is stored as a single byte. No additional 0 (zero) byte is added
to the string (as would be done for strings in C). If the memory
resource is smaller than needed by the offset and bytes to store,
it is expanded to fit.

The mputstring function returns true on success and false
on failure.

....mputptr

	bool mputptr(resource mem, int offset, resource ptr)

The mputptr function stores a pointer to the memory associated
with the memory resource "ptr" into the memory resource "mem",
using "offset" as a byte offset from the start of the target
memory resource. If the memory resource is smaller than needed
by the offset and stored pointer, it is expanded to fit.

If the resource value "ptr" is freed (by going out of scope
or being unset) before the resource value "mem", the pointer
stored inside "mem" will point to garbage. It is the
responsibility of the programmer to ensure that memory
resources pointing to each other are not freed up in the
wrong order.

The mputptr function returns true on success and false on
failure.

....mgetchar

	mixed mgetchar(resource mem, int offset)

The mgetchar function tries to read one character from the
memory resource "mem", using "offset" as a byte offset from
the start of the memory resource. If this is possible, the
character is returned as an int value. If "mem" is not a
valid memory resource or the offset does not fall into the
allocated memory, void is returned.

....mgetshort

	mixed mgetshort(resource mem, int offset)

The mgetshort function tries to read one short integer from the
memory resource "mem", using "offset" as a byte offset from
the start of the memory resource. If this is possible, the
short integer is returned as an int value. If "mem" is not a
valid memory resource or the offset does not fall into the
allocated memory, void is returned.

....mgetint

	mixed mgetint(resource mem, int offset)

The mgetint function tries to read one integer from the
memory resource "mem", using "offset" as a byte offset from
the start of the memory resource. If this is possible, the
integer is returned as an int value. If "mem" is not a
valid memory resource or the offset does not fall into the
allocated memory, void is returned.

....mgetfloat

	mixed mgetfloat(resource mem, int offset)

The mgetfloat function tries to read one "float" value from the
memory resource "mem", using "offset" as a byte offset from
the start of the memory resource. If this is possible, the
C float is returned as a float value. If "mem" is not a
valid memory resource or the offset does not fall into the
allocated memory, void is returned.

....mgetdouble

	mixed mgetdouble(resource mem, int offset)

The mgetdouble function tries to read one "double" value from
the memory resource "mem", using "offset" as a byte offset from
the start of the memory resource. If this is possible, the
C double is returned as a float value. If "mem" is not a
valid memory resource or the offset does not fall into the
allocated memory, void is returned.

....mgetstring

	mixed mgetstring(resource mem, int offset, int length)

The mgetstring function tries to read a string value from the
memory resource "mem", using "offset" as a byte offset from
the start of the memory resource. "length" bytes are read from
the memory resource and returned in the form of a string
value, each byte making up one character of the string.
Processing does not stop when encountering a 0 (zero) byte in
the memory resource.

If "mem" is not a valid memory resource or offset plus
length do not fall into the allocated memory of the resource,
void is returned.

....mgetptr

	mixed mgetptr(resource mem, int offset, bool free)

The mgetptr function tries to read one pointer from the
memory resource "mem", using "offset" as a byte offset from
the start of the memory resource. If this is possible, the
pointer is returned in the form of a new memory resource
that points to the same memory as the original pointer.
If the "free" argument is true, the memory pointed to by
the memory resource will be freed when the memory resource
goes out of scope or is unset. If it is "false", the memory
will not be freed up.

If "mem" is not a valid memory resource or the offset does not
fall into the allocated memory, void is returned.

The resulting memory value does not have a known size (msize
returns zero) and is read-only.

....mstring

	mixed mstring(resource mem, int offset)

The mstring function tries to create a string based on a
C string (zero-terminated character array) found in the
memory resource "mem" and starting at byte offset "offset"
from the start of the memory resource. On success, the
resulting Intend C string is returned. If "mem" is not a
valid memory resource or the offset does not fall into
the allocated memory, void is returned.

....is_rw

	bool is_rw(resource mem)

The is_rw function returns true if the memory resource
"mem" is a valid memory resource and writable. It
returns false otherwise.

....msize

	mixed msize(resource mem)

The msize function returns the number of bytes currently
allocated for the memory resource "mem". This value is
0 (zero) if the size is not known, which can happen if the
resource was obtained by reading a C pointer. If "mem" is
not a valid memory resource, msize returns void.

....memcpy

	bool memcpy(resource dst, int dst_off, resource src,
	            int src_off, int count)

The memcpy function copies "count" bytes from the memory
resource "src" to the memory resource "dst". "src_off" is
used as an offset into the source resource and "dst_off"
is used as an offset into the destination resource. If the
destination memory resource is not large enough to hold the
new data, it is extended accordingly. If the destination
offset is beyond the end of the destination resource, the
bytes between the previous end of the resource and the
destination offset are undefined after the operation.

If the source and destination resources overlap, the
resulting bytes in the destination resource have undefined
values.

The memcpy function returns true if the operation succeeded,
or false if one of the input resources was not a memory
resource.

....memmove

	bool memmove(resource dst, int dst_off, resource src,
	            int src_off, int count)

The memmove function copies "count" bytes from the memory
resource "src" to the memory resource "dst". "src_off" is
used as an offset into the source resource and "dst_off"
is used as an offset into the destination resource. If the
destination memory resource is not large enough to hold the
new data, it is extended accordingly. If the destination
offset is beyond the end of the destination resource, the
bytes between the previous end of the resource and the
destination offset are undefined after the operation.

If the source and destination resources overlap, the memmove
function takes care that the correct bytes are copied to
the destination resource and offset.

The memmove function returns true if the operation succeeded,
or false if one of the input resources was not a memory
resource.

....memcmp

	mixed memcmp(resource one, int one_off, resource two,
	             int two_off, int count)

The memcmp function compares the bytes stored in the memory
resources "one" and "two". At most "count" bytes are compared
and "one_off" is used as an offset into memory resource "one"
while "two_off" is used as an offset into memory resource
"two". If any of the resources is not large enough to contain
"count" bytes after taking the offset into account, or if one
of the input resources is not a memory resource, the memcmp
function returns void.

The bytes in the two memory resources are compared one by one.
If memcmp encounters a byte in memory resource "one" that is
smaller than the corresponding byte in resource "two", a
negative int value is returned. If memory resource "one" contains
a byte that is larger than the corresponding byte in resource
"two", a positive int value is returned. Otherwise, the
comparison moves on to the next byte in both resources. If
the bytes in both resources prove to be identical, an int
value of 0 (zero) is returned.

....memchr

	mixed memchr(resource mem, int offset, int what, int count)

The memchr function searches the memory resource "mem" for a
byte containing the value "what", with "what" truncated to
eight bits. The search starts at the offset "offset" and
searches a maximum of "count" bytes starting from the given
offset.

The memchr function returns void if "mem" is not a memory
resource, the offset and count exceed the size of the memory
resource, or the given byte is not found inside the resource.
If the given byte is found inside the memory resource, the
memchr function returns an int value giving the offset from the
start of the memory resource where the byte was found.

....memset

	bool memset(resource mem, int offset, int what, int count)

The memset function truncates "what" to eight bits and fills
the memory resource "mem" with the resulting byte. Filling
starts at the offset "offset" inside the resource and continues
for "count" bytes. The memory resource is automatically resized
if its current size is not large enough to hold the generated
bytes.

The memset function returns true if the operation succeeded,
or false if the given resource was not a memory resource.

..Regular Expressions module ("preg")

Intend C has a module named "preg" that can be loaded on
systems with the PCRE (Perl Compatible Regular Expressions)
library installed. This group of functions provides versatile
support for matching regular expressions against strings.

This module implements also some global constants like the
PREG_ANCHORED that are to be used by the functions that have
an options argument.

...Globals

....PREG_ANCHORED

	PREG_ANCHORED

The int variable PREG_ANCHORED is initialised to contain
the option value for forcing a regular expression to match
only at the first possible matching point in subject string.
It can be passed to all functions that take PREG options.

....PREG_CASELESS

	PREG_CASELESS

The int variable PREG_CASELESS is initialised to contain
the option value for forcing a regular expression to perform
a case-insensitive match. This option value can only be
used when compiling a regular expression.

....PREG_DOLLAR_ENDONLY

	PREG_DOLLAR_ENDONLY

The int variable PREG_DOLLAR_ENDONLY is initialised to contain
the option value for forcing the dollar meta character in a
regular expression to match only at the end of a subject
string. Normally it also matches directly before the last
character of the string if the last character is a newline
character. This option value can only be used when compiling
a regular expression.

....PREG_DOTALL

	PREG_DOTALL

The int variable PREG_DOTALL is initialised to contain the
option value for making the dot meta character in a regular
expression match all characters. Normally it doesn't match
newline characters. This option value can only be used when
compiling a regular expression.

....PREG_EXTENDED

	PREG_EXTENDED

The int variable PREG_EXTENDED is initialised to contain the
option value for making PCRE ignore whitespace characters
in a regular expression and ignore all characters between
the "#" (hash) character and the next newline following it.
This makes it possible to embed comments in regular
expressions. This option value can only be used when compiling
a regular expression.

....PREG_MULTILINE

	PREG_MULTILINE

The int variable PREG_MULTILINE is initialised to contain the
option value for making a regular expression treat a subject
string as consisting of multiple lines. Normally the whole
subject string is treated as a single line. This option value
can only be used when compiling a regular expression.

....PREG_UNGREEDY

	PREG_UNGREEDY

The int variable PREG_UNGREEDY is initialised to contain the
option value for reversing the greediness of quantifiers in
a regular expression so that they are not greedy by default.
This option value can only be used when compiling a regular
expression.

....PREG_NOTBOL

	PREG_NOTBOL

The int variable PREG_NOTBOL is initialised to contain the
option value that makes a regular expression not consider
the beginning of a subject string to be the beginning of a
line. This option value can only be used when matching a
regular expression.

....PREG_NOTEOL

	PREG_NOTEOL

The int variable PREG_NOTEOL is initialised to contain the
option value that makes a regular expression not consider
the end of a subject string to be the end of a line. This
option can only be used when matching a regular expression.

....PREG_NOTEMPTY

	PREG_NOTEMPTY

The int variable PREG_NOTEMPTY is initialised to contain the
option value that makes a regular expression and its
subexpressions not match empty subject strings. This option
can only be used when matching a regular expression.

...Functions

....is_preg_resource

	bool is_preg_resource(resource res)

The is_preg_resource returns true if the resource "res"
is a resource for a compiled regular expression. It returns
false otherwise.

....preg_compile

	mixed preg_compile(string pattern, int options)

The preg_compile function compiles the regular expression
"pattern" into an internal format used by the PCRE library.
Additional options can be passed in the "options" argument.
If the pattern can be compiled successfully, a resource for
the compiled pattern is returned. On error, void is
returned.

When the resource value returned by pcre_compile is unset
or goes out of scope, the compiled regular expression is
freed.

For the exact syntax and semantics of the supported regular
expressions, please refer to the PCRE documentation which
can be found online at:

	http://www.pcre.org/

....preg_match

	bool preg_match(resource reg, string x, int options)

The pcre_match function returns true if the regular
expression associated with the resource "reg" matches the
string "x". Additional options can be passed in the "options"
argument. If the regular expression does not match the
string, false is returned.

....preg_exec

	mixed pcre_exec(resource reg, string x, int options)

The pcre_exec function returns detailed information about
how the regular expression associated with the resource "reg"
matches the string "x". Additional options can be passed in
the "options" argument.

If there is an error while matching the regular expression,
void is returned. If the regular expression does not match
the string, an empty array is returned.

If the regular expression matches the string, an array with
information about the exact matching parts of the string is
returned. The first element of the resulting array contains
the part of the input string that matches the whole regular
expression.

If the regular expression contains subexpressions in
parenthesis, these are counted starting from one and the
part of the string that matched each subexpression is
contained in the resulting array at the same index. 
Subexpressions from the end of the expression that were
not used in matching are not included in the result array.
If subexpression n is not used for matching but
subexpression n+1 is, the value used for subexpression n
in the result array is a void value. This allows the
programmer do distinguish between a subexpression not
matching at all and matching an empty string.

....preg_free

	void preg_free(resource reg)

The preg_free function frees the regular expression associated
with the resource "reg". Later calls to PREG Module functions
with the same resource will act as if the resource is not a
valid regular expression resource.

..Error functions module ("err")

This module implements some system functions that allow control
over system and file errors from Intend C scripts.

...Globals

....errno constants

The errno values are defined by the ISO C standard to be of
type int; errno values in Intend C are returned by the function
errno(). Valid error numbers are all nonzero; errno is never
set to zero by any library function. All the error names
specified by POSIX.1 must have distinct values, with the
exception of EAGAIN and EWOULDBLOCK, which may be the same.
Below is a list of the symbolic error names that are defined
on Linux. Some of these are marked POSIX.1, indicating that the
name is defined by POSIX.1-2001, or C99, indicating that the
name is defined by C99.

	E2BIG

Argument list too long (POSIX.1)

	EACCES

Permission denied (POSIX.1)

	EADDRINUSE

Address already in use (POSIX.1)

	EADDRNOTAVAIL

Address not available (POSIX.1)

	EAFNOSUPPORT

Address family not supported (POSIX.1)

	EAGAIN

Resource temporarily unavailable (may be the same value as EWOULDBLOCK) (POSIX.1)

	EALREADY

Connection already in progress (POSIX.1)

	EBADE

Invalid exchange

	EBADF

Bad file descriptor (POSIX.1)

	EBADFD

File descriptor in bad state

	EBADMSG

Bad message (POSIX.1)

	EBADR

Invalid request descriptor

	EBADRQC

Invalid request code

	EBADSLT

Invalid slot

	EBUSY

Device or resource busy (POSIX.1)

	ECANCELED

Operation canceled (POSIX.1)

	ECHILD

No child processes (POSIX.1)

	ECHRNG

Channel number out of range

	ECOMM

Communication error on send

	ECONNABORTED

Connection aborted (POSIX.1)

	ECONNREFUSED

Connection refused (POSIX.1)

	ECONNRESET

Connection reset (POSIX.1)

	EDEADLK

Resource deadlock avoided (POSIX.1)

	EDEADLOCK

Synonym for EDEADLK

	EDESTADDRREQ

Destination address required (POSIX.1)

	EDOM

Mathematics argument out of domain of function (POSIX.1, C99)

	EDQUOT

Disk quota exceeded (POSIX.1)

	EEXIST

File exists (POSIX.1)

	EFAULT

Bad address (POSIX.1)

	EFBIG

File too large (POSIX.1)

	EHOSTDOWN

Host is down

	EHOSTUNREACH

Host is unreachable (POSIX.1)

	EIDRM

Identifier removed (POSIX.1)

	EILSEQ

Illegal byte sequence (POSIX.1, C99)

	EINPROGRESS

Operation in progress (POSIX.1)

	EINTR

Interrupted function call (POSIX.1)

	EINVAL

Invalid argument (POSIX.1)

	EIO

Input/output error (POSIX.1)

	EISCONN

Socket is connected (POSIX.1)

	EISDIR

Is a directory (POSIX.1)

	EISNAM

Is a named type file

	EKEYEXPIRED

Key has expired

	EKEYREJECTED

Key was rejected by service

	EKEYREVOKED

Key has been revoked

	EL2HLT

Level 2 halted

	EL2NSYNC

Level 2 not synchronized

	EL3HLT

Level 3 halted

	EL3RST

Level 3 halted

	ELIBACC

Cannot access a needed shared library

	ELIBBAD

Accessing a corrupted shared library

	ELIBMAX

Attempting to link in too many shared libraries

	ELIBSCN

lib section in a.out corrupted

	ELIBEXEC

Cannot exec a shared library directly

	ELOOP

Too many levels of symbolic links (POSIX.1)

	EMEDIUMTYPE

Wrong medium type

	EMFILE

Too many open files (POSIX.1)

	EMLINK

Too many links (POSIX.1)

	EMSGSIZE

Message too long (POSIX.1)

	EMULTIHOP

Multihop attempted (POSIX.1)

	ENAMETOOLONG

Filename too long (POSIX.1)

	ENETDOWN

Network is down (POSIX.1)

	ENETRESET

Connection aborted by network (POSIX.1)

	ENETUNREACH

Network unreachable (POSIX.1)

	ENFILE

Too many open files in system (POSIX.1)

	ENOBUFS

No buffer space available (POSIX.1 (XSI STREAMS option))

	ENODATA

No message is available on the STREAM head read queue (POSIX.1)

	ENODEV

No such device (POSIX.1)

	ENOENT

No such file or directory (POSIX.1)

	ENOEXEC

Exec format error (POSIX.1)

	ENOKEY

Required key not available

	ENOLCK

No locks available (POSIX.1)

	ENOLINK

Link has been severed (POSIX.1)

	ENOMEDIUM

No medium found

	ENOMEM

Not enough space (POSIX.1)

	ENOMSG

No message of the desired type (POSIX.1)

	ENONET

Machine is not on the network

	ENOPKG

Package not installed

	ENOPROTOOPT

Protocol not available (POSIX.1)

	ENOSPC

No space left on device (POSIX.1)

	ENOSR

No STREAM resources (POSIX.1 (XSI STREAMS option))

	ENOSTR

Not a STREAM (POSIX.1 (XSI STREAMS option))

	ENOSYS

Function not implemented (POSIX.1)

	ENOTBLK

Block device required

	ENOTCONN

The socket is not connected (POSIX.1)

	ENOTDIR

Not a directory (POSIX.1)

	ENOTEMPTY

Directory not empty (POSIX.1)

	ENOTSOCK

Not a socket (POSIX.1)

	ENOTSUP

Operation not supported (POSIX.1)

	ENOTTY

Inappropriate I/O control operation (POSIX.1)

	ENOTUNIQ

Name not unique on network

	ENXIO

No such device or address (POSIX.1)

	EOPNOTSUPP

Operation not supported on socket (POSIX.1)
(ENOTSUP and EOPNOTSUPP have the same value on Linux, but
according to POSIX.1 these error values should be distinct.)

	EOVERFLOW

Value too large to be stored in data type (POSIX.1)

	EPERM

Operation not permitted (POSIX.1)

	EPFNOSUPPORT

Protocol family not supported

	EPIPE

Broken pipe (POSIX.1)

	EPROTO

Protocol error (POSIX.1)

	EPROTONOSUPPORT

Protocol not supported (POSIX.1)

	EPROTOTYPE

Protocol wrong type for socket (POSIX.1)

	ERANGE

Result too large (POSIX.1, C99)

	EREMCHG

Remote address changed

	EREMOTE

Object is remote

	EREMOTEIO

Remote I/O error

	ERESTART

Interrupted system call should be restarted

	EROFS

Read-only file system (POSIX.1)

	ESHUTDOWN

Cannot send after transport endpoint shutdown

	ESPIPE

Invalid seek (POSIX.1)

	ESOCKTNOSUPPORT

Socket type not supported

	ESRCH

No such process (POSIX.1)

	ESTALE

Stale file handle (POSIX.1) This error can occur for NFS and
for other file systems

	ESTRPIPE

Streams pipe error

	ETIME

Timer expired (POSIX.1 (XSI STREAMS option))
(POSIX.1 says "STREAM ioctl(2) timeout")

	ETIMEDOUT

Connection timed out (POSIX.1)

	ETXTBSY

Text file busy (POSIX.1)

	EUCLEAN

Structure needs cleaning

	EUNATCH

Protocol driver not attached

	EUSERS

Too many users

	EWOULDBLOCK

Operation would block (may be same value as EAGAIN) (POSIX.1)

	EXDEV

Improper link (POSIX.1)

	EXFULL

Exchange full

...Functions

....errno

	int errno()

The errno function returns an int value describing the last I/O
error that was encountered. The actual set of possible values
depends on the operating system being used.

A common mistake is to do the following:

	if (somecall() == -1) {
	    printf("somecall() failed\n");
	    if (errno() == ...) { ... }
	}

where errno() no longer needs to return the value it had upon
return from somecall() (i.e., it may have been changed by the
printf() call). If the value of errno() should be preserved
across a library call, it must be saved like this:

if (somecall() == -1) {
    errsv = errno();
    printf("somecall() failed\n");
    if (errsv == ...) { ... }
}

....strerror

	string strerror(int error)

The strerror function takes an operating system "error"
value as returned by the errno function and returns a
string describing the error in a human-readable form.
Language and format of the string depend on the operating
system being used.

This function is mainly intended for displaying I/O errors
to the user as it is supposed to use the same messages
as the operating system and its tools.

....perror

	void perror()
	void perror(string prefix)

This function prints a human readable error message based on the
value of errno(), that may be defined from the majority of the
file and system library functions. If we pass a string argument
perror() will print that string as a prefix, followed by a colon
and a space, preceeding the error message.

....printerr

	void printerr(...)

This function casts all it's arguments to string and prints them
to the standard error stream (stderr).

..System functions module ("sys")

This module implements some system functions that allow control
over errors, allow to run system commands and executables and
other system functions like fork or daemon control from Intend C
scripts.

NOTE: Be aware that this module does not filter any access if
running in safe mode and that it is not recommended the use of
this module in safe mode environments.

...Globals

....Signal constants

	SIGHUP

Hangup detected on controlling terminal or death of
controlling process.

	SIGINT

Interrupt from keyboard.

	SIGQUIT

Quit from keyboard.

	SIGILL

Illegal Instruction.

	SIGTRAP

Trace/breakpoint trap.

	SIGABRT

Abort signal.

	SIGIOT

IOT trap. A synonym for SIGABRT.

	SIGBUS

Bus error (bad memory access).

	SIGFPE

Floating point exception.

	SIGKILL

Kill signal.

	SIGUSR1

User-defined signal 1.

	SIGSEGV

Invalid memory reference (Segmentation fault).

	SIGUSR2

User-defined signal 2.

	SIGPIPE

Broken pipe: write to pipe with no readers.

	SIGALRM

Timer signal from alarm().

	SIGTERM

Termination signal.

	SIGSTKFLT

Stack fault on coprocessor (unused).

	SIGCLD

A synonym for SIGCHLD.

	SIGCHLD

Child process stopped or terminated.

	SIGCONT

Continue process if stopped.

	SIGSTOP

Stop process.

	SIGTSTP

Stop typed at tty.

	SIGTTIN

tty input for background process.

	SIGTTOU

tty output for background process.

	SIGURG

Urgent condition on socket (4.2BSD).

	SIGXCPU

CPU time limit exceeded (4.2BSD).

	SIGXFSZ

File size limit exceeded (4.2BSD).

	SIGVTALRM

Virtual alarm clock (4.2BSD).

	SIGPROF

Profiling timer expired.

	SIGWINCH

Window resize signal (4.3BSD, Sun).

	SIGPOLL

Pollable event (Sys V). Synonym for SIGIO.

	SIGIO

Term  I/O now possible (4.2BSD).

	SIGPWR

Power failure (System V)

	SIGSYS

Bad argument to routine (SVr4).

	SIGUNUSED

Unused signal (will be SIGSYS).

	SIGRTMIN

Minimum signal value available for real-time signals.

	SIGRTMAX

Maximum signal value available for real-time signals.

....Signal handling constants

	SIG_IGN

This constant when passed to signal function redefines the
process signal handling to ignore all signals.

	SIG_DFL

This constant when passed to signal function redefines the
process signal handling to the default handlers for all signals.

...Functions

....getuid

	int getuid()

Returns the real user ID of the current process.

....geteuid

	int geteuid()

Returns the effective user ID of the current process.

....getgid

	int getgid()

Returns the real group ID of the current process.

....getegid

	int getgid()

Returns the effective group ID of the current process.

....getgroups

	mixed getgroups()

Returns an array of supplementary group IDs of the current
process. In case of error returns void.

....group_member

	bool group_member(int gid)

This function checks if the current process has gid in the
groups it belongs to.

....setuid

	bool setuid(int uid)

Set the user ID of the calling process to uid. If the calling
process is the super-user, set the real and effective user IDs,
and the saved set-user-ID to uid; if not, the effective user
ID is set to uid.

....setgid

	bool setgid(int uid)

Set the group ID of the calling process to gid. If the calling
process is the super-user, set the real and effective group IDs,
and the saved set-group-ID to gid; if not, the effective group
ID is set to gid.

....sleep

	int sleep(int seconds)

Make the process sleep for a number of seconds, or until a
signal arrives and is not ignored.  The function returns the
number of seconds less than seconds which it actually slept
(thus zero if it slept the full time). There is no return
value to indicate error, but if `sleep' returns SECONDS,
it probably didn't work.

....fork

	int fork()
	int fork(fn func)

Clone the calling process, creating an exact copy. If called
without argument, returns -1 for errors, 0 to the new process,
and the process ID of the new process to the old process. If a
function is passed as argument, it will only return the pid of
the new process to the old process, and the new process will
start by calling the passed function without arguments and will
return the function int return value.

....daemon

	bool daemon(bool nochdir, bool noclose)

The daemon function is for programs wishing to detach from the
controlling terminal and run in the background as system
daemons. Unless the argument nochdir is true, daemon changes
the current working directory to the root ("/"). Unless the
argument noclose is true, daemon will redirect standard input,
standard output and standard error to /dev/null. On success
true will be returned. If an error occurs, daemon returns
false and sets errno to any of the errors that occurred.

....getpid

	int getpid()

Returns the process ID of the current process.

....getppid

	int getppid()

Returns the process ID of the parent of current process.

....waitpid

	int waitpid(int pid)

Wait for the process pid to terminate, returning its exit
status.

....signal

	bool signal(mixed sighandler)

This function sets a signal handler function to all signals.
The signal handler function must be an Intend C function defined
like in the following example:

	// This is a signal handler function
	void sig_handler(int sig)
	{
	    ...
	}
	
	// Register the signal handler
	if(!signal(sig_handler)) {
	    print("error registering signal handler\n");
	    exit(1);
	}

Otherwise, this function can receive SIG_IGN constant to ignore
all signals, or SIG_DFL constants to set the signal handler to
the default handler.

....strsignal

	string strsignal(int sig)

The strsignal function returns a string with a human readable
message for the passed signal value.

....psignal

	void psignal(int sig)
	void psignal(int sig, string prefix)

This function prints a human readable message for the passed
signal value. If an optional prefix string is passed, the
function prints the prefix with a colon and a space before the
message.

....raise

	bool raise(int sig)

The raise function sends a sig signal to the own process.

....kill

	int kill(int pid)
	int kill(int pid, int sig)

The kill function sends a sig signal to the process identified
by pid.

....alarm

	int alarm(int sec)

This function schedules an alarm to be send as a SIGALRM signal
to the current process in sec seconds. Returns the number of
seconds remaining until any previously scheduled alarm was due
to be delivered, or zero if there was no previously scheduled
alarm.

....pause

	void pause()

This function causes the invoking process to sleep until a
signal is received that either terminates it or causes it to
call a signal handling function. Returns when a signal was
caught and the signal handling function returned. In this
case errno is set to EINTR.

....system

	mixed system(string command, array args)
	mixed system(string command, array args,
	             mixed in)
	mixed system(string command, array args,
	             mixed in, mixed &out)
	mixed system(string command, array args,
	             mixed in, mixed &out, mixed &err)

This function starts a new process running the passed command
with supplied args array arguments. The command passed is the
executable file only. The executable arguments must be placed
in the args array. The command will be searched in PATH if not
started be a '/' character. Optional arguments in, out and err
allow IO redirection from and to Intend C variables. The in, if
passed, will be cast to string and used as stdin to the command.
The out and err, if passed, will receive from stdout and stderr
respectively the outputs of the command and assigned to the
referenced variables (must include the & before the names).
This function invokes the command directly without a command
interpreter (shell) to allow best performance. On success  this
function returns the exit status of the executed command. On
error void will be returned and errno set accordingly.

....exec

	mixed exec(string command, array args)

This function substitutes the current process with a new one
executing the passed command with supplied args array arguments.
The command passed is the executable file only. The executable
arguments must be placed in the args array. The command will
be searched in PATH if not started be a '/' character. This
function does invoke the command directly without a command
interpreter (shell) to allow best performance. On success  this
function never exits. On error void will be returned and errno
set accordingly.

..Shell tools module ("shell")

This module implements a shell function that allows to execute
shell commands from inside an Intend C script. Besides this the
module implements functions to invoke the most used shell
utilities like grep, awk, sed, etc...

NOTE: Be aware that this module does not filter any access if
running in safe mode and that it is not recommended the use of
this module in safe mode environments.

...Functions

....shell

	mixed shell(string command)
	mixed shell(string command, mixed in)
	mixed shell(string command, mixed in, mixed &out)
	mixed shell(string command, mixed in, mixed &out,
	            mixed &err)

The system function passes the string "command" to the OS shell,
as a command to execute. Optional arguments in, out and err
allow IO redirection from and to Intend C variables. The in, if
passed, will be cast to string and used as stdin to the command.
The out and err, if passed, will receive from stdout and stderr
respectively the outputs of the command and assigned to the
referenced variables (must include the & before the names).On
success  this function returns the exit status of the executed
command. On error void will be returned and errno set
accordingly.

....grep

	string grep(string expr, mixed input);
	string grep(string expr, mixed input, mixed &err);

This function passes the supplied input to grep shell tool using
the expr search string to find the lines from input that contain
it. Optionally a variable can be passed by reference to receive
the output of errors in stderr. The function returns the output
of grep tool to stdout, that can be assigned to an Intend C
variable. If grep tool was unsuccessful, the function returns
void.

....egrep

	string egrep(string expr, mixed input);
	string egrep(string expr, mixed input, mixed &err);

This function passes the supplied input to grep shell tool using
the expr regular expression string to match the lines from input.
Optionally a variable can be passed by reference to receive the
output of errors in stderr. The function returns the output of
grep tool to stdout, that can be assigned to an Intend C
variable. If grep tool was unsuccessful, the function returns
void.

....awk

	string awk(string expr, mixed input);
	string awk(string expr, mixed input, mixed &err);

This function passes the supplied input to awk shell tool using
the pgm as awk program string to process the lines from input.
Optionally a variable can be passed by reference to receive the
output of errors in stderr. The function returns the output of
awk tool to stdout, that can be assigned to an Intend C
variable. If awk tool was unsuccessful, the function returns
void.

....sed

	string sed(string pgm, mixed input);
	string sed(string pgm, mixed input, mixed &err);

This function passes the supplied input to sed shell tool using
the pgm as sed program string to process the lines from input.
Optionally a variable can be passed by reference to receive the
output of errors in stderr. The function returns the output of
sed tool to stdout, that can be assigned to an Intend C
variable. If sed tool was unsuccessful, the function returns
void.

....uniq

	string uniq(mixed input);
	string uniq(mixed input, mixed &err);

This function passes the supplied input to uniq shell tool to
match the unique lines from. Optionally a variable can be
passed by reference to receive the output of errors in stderr.
The function returns the output of uniq tool to stdout, that
can be assigned to an Intend C variable. If uniq tool was
unsuccessful, the function returns void.

.Interface Description

Here is described the interface with Intend C library, how to
embed Intend C in other programs and how to extend Intend C
by writing new modules.

..Integration in another program

The integration in another program is very easy. First of all
you need to create an Intend C context to work with. It is at
the context that Intend C interpreter writes all the internal
information about the script and configuration parameters. You
create a context with:

	// Intend C context
	intend_ctx context;
	
	// Create  a new context
	context = intend_new_ctx();

After this step, you can setup the execution configuration with
some of these commands:

	// Set safe mode on or of
	intend_safe_mode_set(context, INTEND_SAFE_MODE_ON/OFF);
	
	// Add any number of safe boxes
	intend_sandbox_add(context, name, path, INTEND_SANDBOX_RO/RW);
	
	// Add any number of pre-loaded modules
	intend_module_add_preload(context, modname);
	
	// Set a script server to be used with the interpreter. The
	// passed function must return a FILE * pointing to file or
	// memory stream.
	intend_register_source_callback(context, func);

You can also set the IO streams that will be used by the Intend
C script. This is done by calling these functions:

	// Set the stdin, stdout and stderr IO streams
	intend_stream_set_stdin(ctx, streamin);
	intend_stream_set_stdout(ctx, streamout);
	intend_stream_set_stderr(ctx, streamerr);

The next step should be the context initialization to be ready
to parse a script:

	/* Initialize the context */
	intend_init_ctx(context, argc, argv);

Now we are able to parse our script. We do it with:

	intend_parse_script_file(context, filename);

The above function will return 1 on success and 0 on failure. Now
we will execute the script, and receive the exit code from it:

	status = intend_execute_script(context);

After script execution we can inspect the resulting symbol table
and access any variable or even call individual functions in the
script. Check the API section for more detailed information over
this topic.

After all the work needed with symbol table, we can finaly shut
down the script context to free any resources and we are done...

	intend_free_ctx(context);

Simple isn't it? So what are you waiting for? Integrate Intend C
in your application right now...

..Writing new modules

Writing new Intend C modules is very easy. A module is only a
shared library with some function definitions that will be
registered as Intend C functions and will be available in the
Intend C language as if they were linked into the standard
library. In fact, even the Intend C standard library implements
its functions in a similar way.

What you need to get started is to understand the mechanics of
this very simple architecture and then check some Intend C core
module to see the big picture.

...Module functions array

To simplify the registration of tens of functions, the easier
way to do it is using an array. This is something like:

	static intend_function_data sys_funcs[] = {
	    { "system",     sys_system,     1,  "s",     '?'    },
	    { ...                                               },
	    
	    /* list terminator */
	    { NULL,         NULL,           0,  NULL,    0      }
	};

At the first column, you place a string with the desired name
each function will have inside the Intend C interpreter.

The second column has a pointer to the real C function that
implements the functionality.

In the third there is the number or arguments the function
will accept.

Next is the function prototype. A string with lower and upper
case characters representing each the type or an argument
passed to the function. Lower case are simple types and upper
case are forced types (check above the forced keyword for more
information). The types are like the following:

	character 'b' = bool
	character 'i' = int
	character 'f' = float
	character 's' = string
	character 'a' = array
	character 'c' = struct
	character 'p' = fn
	character 'r' = resource
	character 'v' = void
    character '?' = mixed (any type)

And finaly the return type represented by a character, similar
to the protoype.

To finish the array, a line with NULL's and 0 must be placed,
so that the function that registers or unregisters the functions
will know where to stop iterating the list.

...Module constructor

At the module constructor is where the actual module functions
registration takes place. Usualy the module constructor has one
line of code like this:

	void intend_sys_module_initialize(intend_ctx *ctx)
	{
	    intend_register_function_array(ctx, sys_funcs);
	}

The name of the constructor must be started with "intend_",
followed by the name of the module and then by with the suffix
"_module_initialize". The only argument the constructor will
receive is the context.

This function is called whenever this module is loaded, when
loaded by the use statement, by using the module_load function
or by loading the module using the preload mechanism.

...Module destructor

Similarly to the constructor, the destructor usualy has a line
like the following:

	void intend_sys_module_destroy(intend_ctx *ctx)
	{
	    intend_unregister_function_array(ctx, sys_funcs);
	}

This will unregister all the module functions before the module
actualy get unloaded. This destuctor is called when the script
used module_unload function, or when the context is freed.

...Module function definitions

Now the function definition is the major part of writing a new
module to Intend C. Intend C modules can be developed using C
language, or C++ language with some C function definitions in a
C language interface.

Each function will be called using a simple argc, argv[] type
of calling convension. The required function prototype is:

	intend_value mymod_start(intend_ctx ctx, unsigned int argc,
	                         intend_value *argv)
	{
	    ...
	}

The arguments correspond to context, number of arguments passed
and one array of intend_value pointers with the actual value of
each argument to the call.

To access the passed arguments, use one of the following
functions:

	int intend_value_type(intend_value val);
	int intend_bool_value(intend_value val);
	int intend_int_value(intend_value val);
	double intend_double_value(intend_value val);
	char *intend_string_value(intend_value val);
	char *intend_string_ptr(intend_value val);
	int intend_string_len(intend_value val);
	void *intend_resource_value(intend_value val);
	void *intend_resource_release(intend_value val);
	intend_value intend_array_value(intend_value val,
	                                const int pos);
	int intend_array_count(intend_value val);
	char *intend_fn_name_ptr(intend_value val);

To create the result value, you must call one of the functions:

	intend_value intend_create_value(intend_type type,
	                                 void *data, ...);
	intend_value intend_copy_value(intend_value val);

In the middle of these lines of code, is where the actual module
code is developped in C language.

...Module Class definitions

The modules can also define structure classes that will be
available to the scripts for use with Intend C object oriented
like syntax.

We recommend that every module implement always the functions
for C like usage, and implement the respective classes as a
complement, because this way every user will be allowed to
decide to use the Intend C object oriented like syntax or just
stick to their beloved simplicity of the C syntax.

To register a structure class in Intend C context, simply call

	void intend_register_class(intend_ctx ctx, char *name,
                               intend_function vector,
                               unsigned int args, char *proto);

This function registers a new class in the context ctx, named
name and with the function constructor vector, receiving the
number of arguments specified by args and the prototype proto.
It is just like registering a new function, but instead this
will initialize the class attributes and methods.

The registered constructor should be something like this
example that registers a simple object class like the one
defined in Intend C standard library:

	/*
	 * object class constructor
	 */
	intend_value *object_constructor(intend_ctx ctx,
	                                 unsigned int argc,
	                                 intend_value *argv)
	{
	    intend_value val = argv[0];
	    intend_value this = intend_get_variable(ctx, "this");
	
	    intend_struct_set(this, "_object", val);
	    intend_struct_set_method(this, "tostring", object_tostring, 0, "", 's');
	    intend_struct_set_method(this, "tofloat", object_tofloat, 0, "", 'f');
	    intend_struct_set_method(this, "toint", object_toint, 0, "", 'i');
	
	    return intend_create_value(INTEND_TYPE_VOID, NULL);
	}

This would be equivalent to the Intend C code:

	/*
	 * object class
	 */
	class object {
	    _object = 0;
	
	    void object(mixed val) {
	        this._object = val;
	    }
	
	    string tostring() {
	        ...
	    }
	
	    float tofloat() {
	        ...
	    }
	
	    int toint() {
	        ...
	    }
	
	}

The developer of classes in modules must be aware that these
module classes do not implement inheritance from other classes
so, to implement an extension of a base class, the constructor
of the new class must be responsible to call any other contructors
of the base classes this one wants to extend.

Inside the Intend C script every built-in class is viewed like an
orphan class.

..C API

...Defines

There are some macro definitions in Intend C API to be passed to
configuration functions.

	INTEND_SAFE_MODE_OFF
	INTEND_SAFE_MODE_ON

Obviously, these correspond to turning or checking if safe mode
is on or off respectively and are needed or result of functions
intend_safe_mode_set and intend_safe_mode_get.

	INTEND_SANDBOX_NONE
	INTEND_SANDBOX_RO
	INTEND_SANDBOX_RW

These, when passed to intend_sandbox_add function, will define
the sandbox access permissions.

...Data types

Intend C API defines some data types to ease the use of the
API and encapsulate the internals of Intend C.

....intend_ctx

	typedef void *intend_ctx;

The Intend C context. This is encapsulated in a void pointer.
Most of the functions in Intend C receive this context as first
argument.

....intend_value

	typedef void *intend_value;

All variables received and returned by the module functions or
Intend C standard library will be of this type. This type is
encapsulated and to use it you have the value functions
described below.

....intend_type

	typedef enum {
	    INTEND_TYPE_VOID    = 0,
	    INTEND_TYPE_BOOL    = 1,
	    INTEND_TYPE_INT     = 2,
	    INTEND_TYPE_FLOAT   = 3,
	    INTEND_TYPE_STRING  = 4,
	    INTEND_TYPE_ARRAY   = 5,
	    INTEND_TYPE_STRUCT  = 6,
	    INTEND_TYPE_FN      = 7,
	    INTEND_TYPE_RES     = 8
	} intend_type;

Intend data types. When you create a value or query some values
type this enum is used to specify its type. See Intend C types
for more information about each type.

....intend_function

	typedef intend_value(*intend_function)(
	    intend_ctx ctx, unsigned int argc, intend_value *argv);


Intend pointer type for registered functions. Defines the
prototype to be used in functions that are to be registered in
Intend C. All the functions must return an intend value and
receive the arguments: intend_ctx context, unsigned int
argument count and an array of pointers to intend_value with
the arguments.

....intend_source_callback

	typedef FILE *(*intend_source_callback)(
	    intend_ctx ctx, char *path);

Intend pointer type to register a source callback function. The
function must return a FILE pointer and receive an intend_ctx
context and a string with the desired path.
See intend_register_source_callback function for more details.

....intend_function_data

	typedef struct {
	    char               *name;
	    intend_function     vector;
	    unsigned int        args;
	    char               *proto;
	    char                rettype;
	} intend_function_data;

Intend function definition to be used in the register functions
calls. Fields: name is the function name inside Intend C; vector
is the pointer to an intend_function; args is the number of
arguments or 0 to allow any number; proto is the prototype of
the function defined as a string with the number of characters
equal to the number of arguments and each one representing the
type of the desired argument, see bellow; and rettype is the
return type of the function defined as a character using the
same notation as the prototype.

	prototype and rettype notation:
	
	    'b' = bool
	    'i' = int
	    'f' = float
	    's' = string
	    'a' = array
	    'c' = struct
	    'p' = fn
	    'r' = resource
	    'v' = void
	    '?' = mixed (any type)


....intend_variable_data

	typedef struct {
	    char        *name;
	    intend_type type;
	    void        *value;
	} intend_variable_data;

Intend variable definition to be used in register variable
calls. The fields are self explanatory. The value is a void
pointer because it will get any type depending on the type
field. To this structure you do not feed intend_values, but
regular C types instead to ease the use in constant arrays.

...Context functions

....intend_ctx intend_new_ctx

	intend_ctx intend_new_ctx()

Creates a fresh new Intend C context.

....intend_init_ctx

	void intend_init_ctx
	     (intend_ctx ctx, int argc, char **argv)

Initializes the Intend C context to parse a script. This
function must be called only after all context configuration
is ready.

....intend_inhibit_ctx

	void intend_inhibit_ctx
	     (intend_ctx ctx, const char *name)

Removes a symbol from the symbol table, for instance to inhibit
some standard library function that you don't allow.

....intend_free_ctx

	void intend_free_ctx(intend_ctx ctx)

Frees an Intend C context destroying the context, parsed script
and all symbol tables.

...Context configuration functions

....intend_stream_set_stdin

void intend_stream_set_stdin(intend_ctx ctx, FILE *stream);

This function sets the stdin of the script to some other stream.
The stream can be a file or memory stream. With these functions
Intend C can run scripts that perform console IO to memory
variables inside a host application.

....intend_stream_set_stdout

void intend_stream_set_stdout(intend_ctx ctx, FILE *stream);

This function sets the stdout of the script to some other stream.
The stream can be a file or memory stream. With these functions
Intend C can run scripts that perform console IO to memory
variables inside a host application.

....intend_stream_set_stderr

void intend_stream_set_stderr(intend_ctx ctx, FILE *stream);

This function sets the stderr of the script to some other stream.
The stream can be a file or memory stream. With these functions
Intend C can run scripts that perform console IO to memory
variables inside a host application.

....intend_stream_get_stdin

FILE *intend_stream_get_stdin(intend_ctx ctx);

This function gets the stdin that is currently in use by the
script.

....intend_stream_get_stdout

FILE *intend_stream_get_stdout(intend_ctx ctx);

This function gets the stdout that is currently in use by the
script.

....intend_stream_get_stderr

FILE *intend_stream_get_stderr(intend_ctx ctx);

This function gets the stderr that is currently in use by the
script.

....intend_stream_reset_stdin

void intend_stream_reset_stdin(intend_ctx ctx);

This function resets the stdin of the script to the one that
was set by the host application before the script execution.
This function should only be used inside Intend C modules and
not by the host application.

....intend_stream_reset_stdout

void intend_stream_reset_stdout(intend_ctx ctx);

This function resets the stdout of the script to the one that
was set by the host application before the script execution.
This function should only be used inside Intend C modules and
not by the host application.

....intend_stream_reset_stderr

void intend_stream_reset_stderr(intend_ctx ctx);

This function resets the stderr of the script to the one that
was set by the host application before the script execution.
This function should only be used inside Intend C modules and
not by the host application.

....intend_module_add_preload

	void intend_module_add_preload
	     (intend_ctx ctx, char *name)

Add a module to pre-load list. This allows the use of modules in
safe mode environments, since in safe mode the use of module_load
and module_unload functions is restricted. Then it is up to the
host application to decide which modules will be available.

....intend_safe_mode_set

	void intend_safe_mode_set
	     (intend_ctx ctx, int safe_mode)

Set the safe mode on or off. To safe_mode argument is passed one
of the defines INTEND_SAFE_MODE_ON or INTEND_SAFE_MODE_OFF.

....intend_safe_mode_get

	int intend_safe_mode_get(intend_ctx ctx)

Returns the safe mode state of the passed context. Since you may
be using several contexts at the same time, or inside a module
function you may need to know if safe mode is on to restrict the
use of some functionality, this function allow you to do so.

....intend_sandbox_add

	void intend_sandbox_add
	     (intend_ctx ctx, char *name, char *path, int access)

Adds a sandbox to the supplied context. To access argument is
passed one of the defines INTEND_SANDBOX_RO or INTEND_SANDBOX_RW.
See the section about sandboxes for more information.

....intend_register_source_callback

	void intend_register_source_callback
	     (intend_ctx ctx, intend_source_callback func)

Registers the source callback function to be used when Intend C
needs source code. This callback function gets called any time
Intend C needs a source file, for instance when you call
intend_parse_script_file function, or when a script requests
an include. The use of this function is to allow having pure
in-memory scripting when using Intend C embedded in another
application. The application can have the scripts inside a
database and serve them to Intend C as file pointers to a
memory stream opened with fmemopen() system call.

....intend_get_file

	FILE *intend_get_file(intend_ctx ctx, char *path)

This is the default function supplied by Intend C as the source
callback. It is made public because you may need to override it
for some particular case maintaining the regular functionality
for other cases. If this is the case, just call this function
with the supplied arguments inside the custom
intend_source_callback function you registered.

...Path manipulation functions

....intend_path_resolve

	char *intend_path_resolve(intend_ctx ctx, char *path)

Resolves the sandbox in a path if any. If no sandbox is
passed in the path, in safe mode this function returns NULL, or
if not in safe mode returns the supplied path intact. The use of
this function is to restrict the filesystem use in safe mode.

....intend_path_validate

	char *intend_path_validate(intend_ctx ctx, char *path)

Besides resolving the path as the previous function, this
one validates it also. The return path valid will be an
absolute path. Symbolic links are not expanded to allow their
use inside sandboxes. If a sandbox is supplied, then the
resulting path must start with the absolute path of the
sandbox, or otherwise NULL is returned.
A valid path must be a valid file or directory existing in
the filesystem. If you need to write a new file, just use
intend_validate_parent instead.

....intend_path_validate_parent

	char *intend_path_validate_parent
	     (intend_ctx ctx, char *path)

The same as the previous functions but removes the last element
of the path before validating and adds it to the result before
returning. It is a shortcut to validate paths of files to be
written.

....intend_path_access

	int intend_path_access(intend_ctx ctx, char *path)

Returns the access permissions of a sandboxed path. Use it to
check if you are allowed to write to the path supplied.
In safe mode the path must be sandboxed or INTEND_SANDBOX_NONE
is returned.
If path is sandboxed, the sandbox access permissions are
returned, or INTEND_SANDBOX_NONE is returned for invalid
sandboxes.
If not in safe mode and path is not sandboxed this function
returns always INTEND_SANDBOX_RW.
Be aware that this function does not verify filesystem access
permissions.

....intend_path_parent

	char *intend_path_parent(char *path)

Returns the parent of the supplied path. Similar to dirname()
system call but sandbox aware.

....intend_path_file

	char *intend_path_file(char *path)

Returns the last element of the supplied path, wether it is a
file or a directory. Similar to basename() system call.

....intend_path_join

	char *intend_path_join(char *parent, char *file)

Joins a parent path and a filename together to for a correct
path specification.

....intend_path_real

	char *intend_path_real(intend_ctx ctx, char *path);

This function returns the real absolute path of the path
supplied in argument path. It is similar to the realpath
function of the standard C library, expanding sandboxes
and symbolic links.

NOTE: This function should not be used to paths that should
allow sandbox usage, as symbolic links inside some sandboxes
may resolve to a path outside them and get invalid access
afterwards. Use intend_path_absolute instead.

....intend_path_absolute

	char *intend_path_absolute(intend_ctx ctx, char *path);

This function returns the absolute path of the path supplied
in argument path. It is similar to the intend_path_real
function but does not expand symbolic links. To allow symbolic
links inside sandboxes, this function should be used instead of
intend_path_real.

...Script administration functions

....intend_parse_script_file

	int intend_parse_script_file(intend_ctx ctx, char *name)

Parse a script to the supplied context from a file path.

....intend_parse_script_buffer

	int intend_parse_script_buffer(intend_ctx ctx, char *script)

Parse a script to the supplied context from a string buffer.

....intend_execute_script

	int intend_execute_script(intend_ctx ctx)

Run the already parsed script from the context. If the passed
context does not have a parsed script, this function returns
-1, otherwise it returns the script result value as passed to
Intend C exit function.

....intend_execute_function

	intend_value intend_execute_function
	     (intend_ctx ctx, const char *name, ...)

Call a function inside a parsed script from the context, creating
an argument list from suplied C language arguments. The variable
arguments must correspond to the function prototype or an error
will be raised. This function returns the value returned by the
called function.

....intend_call_function_list

	intend_value intend_call_function_list(intend_ctx ctx,
	    const char *name, int argc, intend_value *argv);

Call an Intend C function inside a parsed script from the context,
with the suplied argument list. This function returns the value
returned by the called function.

....intend_call_function

	intend_value intend_call_function(intend_ctx ctx,
	    const char *name, int argc, ...);

Call an Intend C function inside a parsed script from the context,
creating an argument list from the supplied Intend C values list.
Argument argc contains the number of arguments in the list that
follows it. This function returns the value returned by the
called function.

....intend_dump_script

	void intend_dump_script(intend_ctx ctx)

Dump the parser script to Intend C again. This is usefull for
debugging the Intend C internals.

....intend_free_script

	void intend_free_script(intend_ctx ctx)

The parsed script may use some precious memory, so use this
function to free it while using the symbol table to access
the script returned values. The use of this function is not
required as the script will be freed also when the context
is freed. It is supplied only to allow the use of Intend C
in memory restricted devices.

...Error reporting functions

....intend_fatal_error

	void intend_fatal_error
	     (intend_ctx ctx, const char *msg, ...)

Raises a fatal error. The script execution will stop.

....intend_nonfatal_error

	void intend_nonfatal_error
	     (intend_ctx ctx, const char *msg, ...)

Raises a non fatal error. The script execution will continue.

....intend_oom

	void *intend_oom(void *ptr)

Verifies if the supplied ptr is NULL and raises a fatal out of
memory error in that case. Useful with dynamic memory allocation
functions.

....intend_except_throw

	void intend_except_throw(intend_ctx ctx, intend_value ex)

Throws an exception from a module function. If the script called
from inside a try block, the respective catch will get this
exception and handle it, otherwise Intend C will raise an
uncaught exception error.

....intend_except_try

	int intend_except_try(intend_ctx ctx)

Starts a try block inside a module function. This is useful if
that function calls other functions that can throw exceptions.
Don't forget to call intend_except_catch at the same function
to catch any exception that may have been thrown to handle it.

....intend_except_catch

	intend_value intend_except_catch(intend_ctx ctx)

Terminates the previous try block inside the module function.
If an exception has been thrown, this function will return the
respective value to be handled, otherwise an intend_value of
type void is returned.

...Value constructor functions

....intend_create_value

	intend_value intend_create_value(intend_type type,
	    void *data, ...)

Creates an Intend C value of the desired type using data and
next arguments as initial values. The number of arguments that
this function accepts depend on the desired type. So for each
type, the following lines describe the function behaviour:

	val = intend_create_value(INTEND_TYPE_VOID,
	          NULL);

Creates a value of type void. The void type doesn't have value
so for data is passed NULL.

	val = intend_create_value(INTEND_TYPE_BOOL,
	          &int_var);

Creates a value of type bool. The bool type requires an int
value representing false if equal to 0 and true otherwise.

	val = intend_create_value(INTEND_TYPE_INT,
	          &int_var);

Creates a value of type int. The int type requires an int value
to initialize it.

	val = intend_create_value(INTEND_TYPE_FLOAT,
	          &double_var);

Creates a value of type float. The float type requires a double
value to initialize it, since Intend C floats are translated to
C language doubles and vice versa.

	val = intend_create_value(INTEND_TYPE_STRING,
	          char_ptr_var, &int_var);

Creates a value of type string. The string type requires a char
pointer with its initial value and an int with the desired size.
The int address may be NULL and strlen of the char pointer will
then be used. This is because strings in Intend C may contain
'\0' characters, so if the string is a binary string, or contain
the '\0' character in the middle, the size will be required to
create the string correctly.

	val = intend_create_value(INTEND_TYPE_ARRAY,
	          intend_value1, intend_value2, ..., NULL);

Creates a value of type array. The supplied intend_value type
arguments will be added to the created array from position 0
onwards.

	val = intend_create_value(INTEND_TYPE_STRUCT,
	          char_ptr_name1, intend_value1, ..., NULL);



	val = intend_create_value(INTEND_TYPE_FN,
	val = intend_create_value(INTEND_TYPE_RES,


....intend_copy_value

intend_value intend_copy_value(intend_value val);

....intend_cast_value

void intend_cast_value(intend_value *val, intend_type type);

....intend_free_value

void intend_free_value(intend_value val);

...Simple types translation functions

For Intend C simple types like int, float or string, they can
be translated to C language types easily, so these types are
accessed through these translation functions.

If the developer needs to change one intend_value of this kind,
instead of calling set functions, he will free the old one and
create a new one with the desired value. This way, Intend C
interace library implements only the functions to manipulate
more complex types like array, struct, resource or fn.

....intend_value_type

int intend_value_type(intend_value val);

....intend_bool_value

int intend_bool_value(intend_value val);

....intend_int_value

int intend_int_value(intend_value val);

....intend_double_value

double intend_double_value(intend_value val);

....intend_string_value

char *intend_string_value(intend_value val);

....intend_string_ptr

char *intend_string_ptr(intend_value val);

....intend_string_len

int intend_string_len(intend_value val);

...Array type functions TODO

void intend_array_add(intend_value arr, intend_value val);
void intend_array_set(intend_value arr, const int pos, intend_value val);
intend_value intend_array_get(intend_value val, const int pos);
int intend_array_count(intend_value val);
intend_value intend_array_delete(intend_value val, const int pos)

...Struct type functions TODO

intend_value intend_struct_get(intend_value st, const char *pos);
void intend_struct_set(intend_value st, const char *pos, intend_value val);
void intend_struct_delete(intend_value st, const char *pos);
void intend_struct_set_method(intend_value st, const char *method, intend_function vector,
                              unsigned int args, char *proto, char rettype);
intend_value intend_struct_call(intend_ctx ctx, const char *name, const char *method,
                                unsigned int argc, intend_value *argv);

...Resource type functions TODO

void *intend_resource_value(intend_value val);
void *intend_resource_release(intend_value val);
void intend_resource_value_set(intend_value val, void *data);

...Fn type functions TODO

char *intend_fn_name_ptr(intend_value val);

...Symbol table functions TODO

intend_value intend_get_variable(intend_ctx ctx, char *name);
void intend_set_variable(intend_ctx ctx, char *name, intend_value val);

/*
 * Register a variable in the interpreter context
 */
void intend_register_variable(intend_ctx ctx, char *name, intend_type type, void *value);

/*
 * Register a variable in the interpreter context from data struct
 */
void intend_register_variable_data(intend_ctx ctx, intend_variable_data *vdata);

/*
 * Register a variable in the interpreter context from array of data structs
 */
void intend_register_variable_array(intend_ctx ctx, intend_variable_data *vdata);

/*
 * Register a function in the interpreter context
 */
void intend_register_function(intend_ctx ctx, char *name, intend_function vector,
                              unsigned int args, char *proto, char rettype);

/*
 * Register a function in the interpreter context from data struct
 */
void intend_register_function_data(intend_ctx ctx, intend_function_data *fdata);

/*
 * Register a function in the interpreter context from array of data structs
 */
void intend_register_function_array(intend_ctx ctx, intend_function_data *fdata);

/*
 * Unregister a symbol (function or variable) from the interpreter context
 */
void intend_unregister_symbol(intend_ctx ctx, char *symbol);

/*
 * Unregister a variable from the interpreter context from array of data structs
 */
void intend_unregister_variable_array(intend_ctx ctx, intend_variable_data *varray);

/*
 * Unregister a function from the interpreter context from array of data structs
 */
void intend_unregister_function_array(intend_ctx ctx, intend_function_data *farray);

...Command execution functions TODO

/*
 * Execute a system command, redirecting IO if needed and returning the exit status
 */
int intend_run(intend_ctx ctx, intend_value cmd, intend_value cmdargs,
                  intend_value in, intend_value *out, intend_value *err);

/*
 * Execute a system command in a shell, redirecting IO if needed and returning the exit status
 */
int intend_shell(intend_ctx ctx, intend_value cmdline,
                  intend_value in, intend_value *out, intend_value *err);

/*
 * Execute a system command, substituting the current process with it
 */
int intend_exec(intend_ctx ctx, intend_value cmd, intend_value cmdargs);

...Debug helper functions TODO

void intend_value_dump(intend_ctx ctx, intend_value val, int depth, int skip_flag);


..C++ API

TODO: The C++ API will be added in a near future. Or if you need it
you can develop it and send to us... :)

.Evolution

This section describes the changes that were made between
different versions of the language or library.

Language and library can be improved independent of each
other, so each part has a separate listing of changes.

..About versioning

Version 1.0.0 onwards, the library and the language will be
versioned along with the interpreter version. This is to
simplify versioning  and is due to fact that Intend C is now
a modular interpreter and the new functionality will be added
through new Intend C Modules.

Although the versioning is now unified, a separate list of
changes will be maintained in the following sections, so the
user can keep track of the changes in each part of the language.

A new section for changes to Intend C Modules is now maintained
as well.

..TODO log

- Introduce arch() function that returns architecture
information

- Create xstrdup() helper in libmisc

- Add offset to string search functions

- Update test suite to match new functionality (safe mode,
sandboxes, modules)

- Create a C++ API that matches all the functionality of the
C API, allowing easier integration with C++ applications.

..Feature requests log

...Simple debugger compatible with gdb

Something compatible with gdb will never be simple, so this
feature request is on hold to be analysis and 

..Known bugs log

At this moment all bugs have been corrected. Please give us
some work! Or otherwise we will need to start developing the
debugger... 

..How to request a feature or a bug correction?

If you found some bug or need a new feature in Intend C, please
report it in:

	http://sourceforge.net/tracker2/?group_id=240927

to be implemented or added to this section for later analysis
and implementation.

..Language change log

This section describes changes to the language syntax and
semantics.

...Former Language version 1.0 to Language version 2.0

Version 2.0 of the language added the resource datatype and
associated syntax for declaring function return types and
arguments of type resource. This is an incompatible change
because the word "resource" is no longer available as an
identifier.

Negative array indices were changed so that using an index
too large refers to the first element of the array when used
in an assignment. Previously this was a fatal error.

...Former Language version 2.0 to Language version 2.1

Version 2.1 of the language documented the fact that an index
expression in an assignment cannot have side effects on the
same structure or array as the whole assignment expression.

The meaning of equality tests on fn values was changed to be
defined by this manual instead of being defined by an
implementation of the language.

...Former Language version 2.1 to Language version 2.2

Version 2.2 of the language added hexadecimal integer literals.

...Former Language version 2.2 to Version 1.0.0

Version 1.0.0 changed the names of structure templates to
structure classes. This is an incompatible change because
the identifier class is no longer available, as well as the
prior code must change the keyword "template" to "class".
All functions that referred to templates, like is_tmpl, were
renamed also to match class.

Added a new way to construct arrays and structs in a script.
Beside of using a function call to mkarray or mkstruct, now
is possible to construct a class with "new array(" followed
by the initial elements of the array. Structs can be created
in a similar way with "new struct(" followed by a series of
'=' assignment statements separated by ','. On the left side
of it is an identifier that will be the field name and on the
right side is an expression indicating the initial field value.

The strings with single or double quotes have been corrected
to allow the inclusion escaped single or double quotes inside.

..Library change log

This section describes changes to the standard library
of functions.

...Former Library version 1.0 to Library version 1.1

The following variables were added in version 1.1:
FLT_DIG, FLT_EPSILON, FLT_MANT_DIG, FLT_MAX, FLT_MAX_EXP,
FLT_MIN, FLT_MIN_EXP, FLT_RADIX, INT_MAX, INT_MIN, RAND_MAX.

The following functions were added in version 1.1:
cast_to, cons, drop, drop_while, elem, explode, head, implode,
init, intersperse, last, length, ltrim, nil, null, replicate,
rtrim, tail, take, take_while, trim.

...Former Library version 1.1 to Library version 2.0

The prototypes of most file I/O function and of all
dictionary functions were changed to make use of the new
resource datatype. This is an incompatible change because
scripts depending on the argument or return types of these
functions can no longer work.

The following functions were added in version 2.0: calloc,
cnull, cstring,  dyn_call_float, dyn_call_int, dyn_call_ptr,
dyn_call_void, dyn_close, dyn_fn_pointer, dyn_open,
dyn_supported, free, is_resource, is_rw, malloc, mgetchar,
mgetint, mgetptr, mgetshort, mputchar, mputint, mputptr,
mputshort, msize, mstring.

...Former Library version 2.0 to Library version 2.1

The following functions were added in version 2.1:
pcre_compile, pcre_exec, pcre_free, pcre_match, pcre_supported.

...Former Library version 2.1 to Library version 2.2

The following functions were added in version 2.2:
is_dict_resource, is_dyn_resource, is_file_resource,
is_mem_resource, is_pcre_resource, mgetdouble, mgetfloat,
mputdouble, mputfloat.

...Former Library version 2.2 to Library version 2.3

The following function was added in version 2.3: realloc.

...Former Library version 2.3 to Library version 2.4

The following functions were added in version 2.4:
memchr, memcmp, memcpy, memmove, memset.

...Former Library version 2.4 to Library version 2.5

The prototypes of the following functions were changed
in version 2.5 to allow extra arguments to be passed into
the function given as the first argument: drop_while, map,
filter, foldl, foldr, take_while.

The following function was added in version 2.5: is_null.

...Former Library version 2.5 to Library version 2.6

The following functions were added in version 2.6:
cfloat, mgetstring, mputstring.

...Former Library version 2.6 to Library version 2.7

The following function was added in version 2.7: 
function_name.

...Former Library version 2.7 Library version 3.0

The system function was changed to return the raw exit code
as given by the operating system. Previously the return value
had been shifted right by 8 bits.

...Former Library version 3.0 to Version 1.0.0

The versions function has changed to match the new versioning
system.

Some library functions were moved to their own module to reduce
library size and improve library extension by the users. See
Modules change log for a detailed description.

Added the sizeof function, to keep proximity to the C language.

The functions module_load, module_unload and module_is_loaded
were added to allow the user to control module loading when
not running in safe mode.

The SAFE_MODE pre-defined variable was added to allow the
script to behave differently in normal or safe mode.

Added the setenv, unsetenv functions to allow to manipulate the
environment while not in safe mode.

..Modules change log

...Version 1.0.0

Added the modular architecture and passed some of the standard
library functionality to independent modules, namely: foreign
functions to dyn module; math functions to math module; memory
functions to mem module; pcre functions to preg module; system
functions (the ones that execute commands) to sys module;
dictionary functions to dict module; list functions to list
module.

.Credits

This is a list of people who have contributed with something
to Intend C (former Arena) or this particular implementation
of the language. This means not only code changes, but also
testing of the implementation under different operating systems
and sending in meaningful bug reports or feature requests.

Intend C represents the interest and hard work of all the
community and the Intend C Maintainer thanks truthfully to all
of them who had the will to make Intend C better.

Thank you guys!

..Intend C Maintainer

Pedro Reis Colaço <info [at] intendc.org>

..Intend C Contributors

Miguel Tadeu <mtadeunet [at] fusemail.com>

..Former Arena Project Maintainer

Pascal Schmidt <arena-language [at] ewetel.net>

..Former Arena Project Contributors

Bengi Fritsche <eoc [at] eocentral.de>

Hans Bezemer <hansoft [at] bigfoot.com>

Jasper Lievisse Adriaanse <jasper [at] nedbsd.nl>

Dennis Heuer <dh [at] triple-media.com>

Anthony C Howe <achowe [at] snert.com>

Maurice Kinal

Fabian Tschiatschek <fabian.tschiatschek [at] gmx.net>

Claus Assmann <ca+arena [at] esmtp.org>

Alistair Crooks <agc [at] pkgsrc.org>

Sander van Dijk <a.h.vandijk [at] gmail.com>

Liran Nuna <liranuna [at] gmail.com>
